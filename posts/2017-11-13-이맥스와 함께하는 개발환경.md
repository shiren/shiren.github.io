---
layout: post
title:  "이맥스와 함께하는 개발환경"
date:   2017-11-13 13:58:08
categories: emacs
---

## 금단의 영역에 손을 대다

에디터, IDE뿐 아니라 업무에 관련된 새로운 도구가 나오면 꼭 써봐야 직성이 풀리는 성격이었지만 언젠가부터 그놈이 그놈이고 저놈이 그놈이고 새로운 기능이 있어도 개발을 할 때 사용하는 기능들은 매우 한정적이라는 사실을 깨닫게 되었다. 인텔리제이도 일년 이상은 사용해봤지만 프론트 엔드를 주로 개발하기에 딱히 IDE가 필요하지 않았고 수많은 기능들을 거의 사용하지 않다 보니 필요 이상의 도구를 사용하는 느낌이었다. 그런 느낌이 조금씩 자라나던 중 생뚱맞게도 박웅현 작가의 ****여덟 단어**** 라는 책을 읽다가 한가지 결심을 하게 된다. 에디터의 본질은 변함이 없고 고전은 시대를 뛰어넘으며 변함없는 가치를 지닌다. 그렇다. 나는 클래식 에디터인 Vim(빔)과 Emacs(이맥스)를 배워보기로 결심했다. 

클래식 에디터의 키 바인딩에 익숙해지면 모던 에디터에서도 해당 키바인딩을 지원하는 경우가 많아 상황에 따라 어떻게든 도움 될 수 있으니 일단 배워두자는 생각이었고 두 에디터가 강력하다는 것은 익히 들어 알고 있었기 때문에 적응만 하면 분명 뭐든 메인 에디터가 될 거라는 믿음이 있었기 때문이었다. 빔을 먼저 시작했고 1년이 조금 안 되게 사용해봤다. 꽤 익숙하게 사용했기 때문에 특별히 이맥스를 새로 배울 생각은 없었지만 빔은 빔 자체만으로는 모든 게 커버가 되지 않았다. Tmux라는 터미널 멀티플레서를 사용해야 했고 한글 지원이 불편해 문서작업이 불가능했으며 빔은 비동기로 외부 프로세스를 실행할 방법이 없어(vim8부터는 가능) 정적 분석 플러그인이 돌아갈 때마다 멈추는 등의 문제가 있었다. 그리고 간단한 플러그인 정도는 만들고 싶었지만, 빔의 플러그인 개발 언어인 Vimscript는 따로 배우고 싶은 마음이 전혀 들지 않았다.

그리고 [Youtube 동영상](https://www.youtube.com/watch?v=8vdOrsywra0)을 보게 된 후 여러 아티클과 다른 이맥스 관련 유튜브 동영상을 찾아보게 되었고 나는 다시 힘든 여정을 시작했다. 이제 이맥스를 사용한지 어느덧 1년 하고도 한 달이 지났다. 이제 나름 안정적인 환경을 구축했고 전혀 불편함이 없이 능수능란하게 다룬다고 생각하고 있다. 개발뿐만 아니라 프로젝트 관리 및 일정 관리 그리고 문서 작업까지 거의 대부분의 업무를 이맥스와 함께한다. 이 글 역시 이맥스에서 작성되고 있다. 이맥스는 플러그인을 모드라고 부르는데 필요한 모드를 개발하기 위해 리스프까지 공부하고있다.(정확히는 emacs-lisp) 빔스크립트보다는 리스프가 여러모로 나아 보였다. 심지어 이를 계기로 리스프라는 언어에 매력이 느껴져 리스프의 자손인 Clojure도 조금씩 공부하고 있다. 한마디로 완전히 이맥스라는 도구에 푹 빠져살고 있다. 최근엔 유명한 책 `클린 코드` 뒷부분에서 이맥스를 떠나 인텔리제이에 정착했다고 밝혔던 엉클 밥이 형도 결국 다시 이맥스로 돌아왔다.([관련 트윗](https://twitter.com/unclebobmartin/status/759732015583358976?lang=en))

클래식 에디터를 배우고 사용하는 건 그 자체가 놀이고 공부라고 생각한다. 정말 재미있다. 꼭 한 번은 도전해보길 바라는 마음에 이 글을 쓴다. 

자 이제 나는 개발만 잘하면 된다.

&#x2026;


## 터미널이 아니다 OS에 맞는 빌드를 사용한다

이맥스는 기본적으로 터미널에서 사용할 수 있다. 물론 그 용도로 만들어졌지만 터미널 환경에서 사용하면 여러 가지 제약 때문에 불편하다. 별도의 OS빌드를 사용하는 편이 좋다. 특정 OS의 빌드를 사용한다는것은 터미널안이 아닌 별도의 프로그램으로 실행해서 사용한다는 의미다. 특정 OS에 최적화하고 포팅해 네이티브 프레임웍으로 이맥스를 빌드했으니 OS와의 연동이 훌륭해진다. 예를 들어 맥이라면 마우스를 이용해 1필셀 단위로 스크롤이 가능하고 사전 검색 및 윈도우 레이아웃 관리 툴(magnet같은)과의 연동이 가능해지며 전체적으로 터미널보다 퍼포먼스가 좋다. 무엇보다 중요한 건 맥의 경우 커맨드키를 메타키로 바인딩해서 사용해야 편한데 터미널 버전의 이맥스는 그렇게 할 수 없다. 개인적으로 맥을 이용하기에 맥용 빌드중 하나를 추천한다. Mitsuharu Yamamoto라는 아주 훌륭한 일본인의 빌드를 사용하는데 메인 리포는 [여기](https://bitbucket.org/mituharu/emacs-mac/overview)지만 Homebrew용 [리포](https://github.com/railwaycat/homebrew-emacsmacport/releases)에서 다운로드하는게 좋다. Homebrew를 통해 설치해도 되지만 시간이 너무 오래 걸리기도 하고 빌드 에러가 발생하는 경우가 있어 그냥 릴리즈 빌드를 다운로드해서 쓴다. 일단 터미널 빌드가 아닌 OS 전용 빌드를 사용하게 되면 그 쾌적함의 차이를 바로 알 수 있다.


## 모드란?

이맥스는 특정 기능을 하는 프로그램이라기보다는 OS라고 불릴 정도로 리스프기반의 프로그래밍 플랫폼이라고 생각하는게 옳다. 개발환경이 있고 그 위에 추가적인 기능들을 플러그인 형태로 확장해 나가는 방식이다. 이맥스에서는 이러한 플러그인 레이어를 모드라고 부른다. 모드는 메이저 모드와 마이너 모드로 나뉜다. 메이저 모드는 버퍼(모던 에디터에서는 탭?)당 한 개의 모드밖에 로드할 수 없다. 보통 메이저 모드는 버퍼에 코딩된 프로그래밍 언어의 신택스 하일라이팅, 자동완성, 인덴테이션등을 지원해주는 플러그인이거나 내부 응용프로그램 하나에 대응한다. 자바스크립트로는 js2-mode가 있고 swift, go, python 등 대부분의 언어는 한개 이상의 메이저 모드들이 존재하고 개발되고 있다. 그리고 마이너 모드가 있다. 마이너 모드는 한 개의 버퍼에 여러 개가 로드될 수 있으며 주로 범언어적인 기능들을 확장한다. 일괄 편집 기능이라던지 정적 분석 모드 혹은 깃의 변경 점을 거터에 표시하는 모드가 이에 해당한다. 보통 언어의 메이저 모드를 하나 선택해서 사용하고(선택의 여지가 있다면) 추가적인 유용한 기능들을 마이너 모드로 확장한다. 그리고 특별히 모드의 형태가 아닌 확장기능들도 있을 수 있고 메이저 모드와 마이너모드를 적절히 사용해 하나의 응용프로그램의 형태로 사용되기도 한다. 이 글의 주된 내용은 각종 기능을 하는 모드들을 소개하는 것이다. 기본적인 사용법은 전혀 다루지 않는다. 우선 관심이라도 끌어야&#x2026;


## 외관
![30](https://user-images.githubusercontent.com/389021/32757999-981a7334-c925-11e7-9d58-b549ba87e3a6.png)
큰 공간은 버퍼인데 정확히는 윈도우 안에 버퍼가 있다고 표현하는 게 맞다. 버퍼를 통해 파일을 편집 한다. 물론 윈도우 분할도 자유롭게 가능하다. 그리고 여러 가지 메세지나 특정 기능에 대한 UI는 미니 버퍼라고 불리는 맨 밑의 공간을 통해 이뤄지는데 검색기능이라면 검색어를 입력받거나 하는 역할을 한다.

![31](https://user-images.githubusercontent.com/389021/32758037-ca55c7ea-c925-11e7-8be3-0cc038ddfb7c.png)

위 스크린샷의 경우는 일시적으로 미니 버퍼의 크기를 키워서 사용하는 케이스다. 보통은 한 줄이다. 이 미니버퍼의 인터페이스도 플러그인 형태로 확장이 되는데 대표적으로 ivy와 helm이 있다.


## 유용한 모드들


### 프로젝트 관리: [Projectile](http://batsov.com/projectile/)(프로젝타일)

이맥스는 파일을 오픈하게 되면 버퍼라는 곳에 들어간다. 흔히 모던 에디터에서 탭이라는 개념과 유사한데 빔(vim)을 다뤄봤던 사람이라면 익숙할 것이다. 이맥스는 기본적으로 버퍼는 그냥 독립된 버퍼들이지 이들 사이에 어떤 연관성이나 그루핑을 지원하지 않는다. 프로젝타일이 이런 버퍼들에 구분을 만들고 독립적인 프로젝트처럼 관리할 수 있게 해준다. 모던 에디터들은 프로젝트별로 독립적인 에디터 인스턴스를 사용하게 되는데 이맥스의 프로젝타일을 사용하면 한 개의 이맥스 인스턴스에서 여러개의 프로젝트를 관리하고 작업할 수 있다. 프로젝트타일에서의 프로젝트는 일반적으로 git(깃) 루트를 기반으로 인식한다. 즉 이맥스 통해 특정 파일을 열게 되면 그 파일이 속해있는 깃 루트를 찾게 되고 존재하면 프로젝트로 자동으로 등록을 해준다. 그래서 특별한 설정 파일 없이도 자동으로 프로젝트를 인식하고 사용할 수 있다. 프로젝타일에는 정말 수많은 기능이 있지만 대표적으로 자주 사용하는 기능 몇 가지만 소개한다. 실제로 그 많은 기능을 다 알지도 못한다.


#### 특정 프로젝트에서 파일 검색

![1](https://user-images.githubusercontent.com/389021/32718992-2ae450ce-c8a2-11e7-9cee-6a2bd0e69175.png)

원하는 프로젝트를 선택하고 

![2](https://user-images.githubusercontent.com/389021/32718991-2aba0620-c8a2-11e7-8cab-5370e909427b.png)

해당 프로젝트에서 파일을 검색해서 불러올 수 있다. 파일 검색은 기본적인 지원도 있고 외부 확장 모듈을 이용할 수 있는데 이 기능뿐 아니라 이맥스에서의 파일 검색은 약간의 설정으로 fuzzy 알고리즘을 기반으로 검색한다고 생각하면 된다.

#### 현재 프로젝트에서 파일 검색

현재 프로젝트에서의 파일검색은 정확히 말하면 현재 열려있고 포커스되어있는 버퍼가 속해 있는 프로젝트에서의 파일 검색이다. 서브라임텍스트의 Jump to file, 빔의 CtrlP에 해당하는 기능이다. 매우 빠르고 편하다.

![4](https://user-images.githubusercontent.com/389021/32718989-2a56a198-c8a2-11e7-84eb-bb52a5d0854f.png)


#### 프로젝트 내 파일 내용 검색(grep)

프로젝타일은 외부의 프로그램을 이용해 프로젝트 내 파일 내용검색을 지원한다. grep, ag, rg를 모두 이용할 수 있는데 개인적으로 rg를 추천한다. 어마어마하게 빠르다. 

![5](https://user-images.githubusercontent.com/389021/32718987-2a275c9e-c8a2-11e7-8975-4f24fc10c8aa.png)

위와 같은 형태로 검색어를 입력하면 실시간으로 검색된 결과가 밑에 노출이 되고 선택하면 해당 위치로 이동할 수 있다. 미니 버퍼 셀렉션을 ivy로 사용하면 여기서 바로 간단하게 단축키로 검색된 내용을 현재 편집하는 버퍼 옆에 윈도우를 열고 버퍼로 만들어 준다. 

![6](https://user-images.githubusercontent.com/389021/32718983-29ba973a-c8a2-11e7-82ef-b50caf966478.png)

`projectile-replace` 로 모든 파일의 일부 내용 replace가 한 번에 가능하긴 하지만 개인적으로 네이밍을 리팩토링하거나 할 때는 모던 에디터들이 지원하는 일괄 편집 보다는 이렇게 열어두고 하나 하나 확인해가며 수정하는 것을 선호한다. 그뿐만 아니라 어떤 함수나 클래스가 어떻게 어디서 사용되는지도 한 눈에 확인할 수 있어 매우 유용하다.

![9](https://user-images.githubusercontent.com/389021/32718960-26ad8840-c8a2-11e7-8cd0-30afabfdf560.gif)


### 워크 스페이스 관리: [Eyebrowse](https://github.com/wasamasa/eyebrowse)(아이브라우즈)

버퍼가 담긴 공간을 윈도우라고 부르는데 이 윈도우는 이맥스 기본 기능만으로도 원하는 대로 분할해 한 화면에 여러 개의 버퍼를 열어 작업할 수 있다. 아이브라우즈는 마치 맥의 스페이스처럼 작업하는 공간을 여러 개로 만들어 사용할 수 있다. 즉 1번 공간에서는 좌우 분활 윈도우로 A파일과 B파일을 열어두고 2번 공간에서는 상하 분활 윈도우로 C와 D를 열어두고 왔다 갔다 하면서 필요한 작업을 수행할 수 있게 해준다. 

![8](https://user-images.githubusercontent.com/389021/32718968-2752b914-c8a2-11e7-8b1b-01b646906ab7.gif)

오른쪽 버퍼 하단 모드라인을 보면 `[1, 2]` 이렇게 스페이스에 대한 정보가 표시된다.


### 프로세스 관리: [Prodigy](https://github.com/rejeep/prodigy.el)(프로디지)

프로디지는 서버를 띄우거나 gulp나 npm script 등의 외부 프로세스를 이맥스에서 편하게 실행할 수 있게 도와주는 프로그램이다. 모드라기보단 이맥스 응용프로그램이다.

![10](https://user-images.githubusercontent.com/389021/32718962-26d6357e-c8a2-11e7-9d55-1cab97dfd2be.png)

실행할 프로세스 설정은 미리 이맥스 설정 파일에서 설정해두면 이렇게 프로디지 버퍼에서 프로세스들을 확인해볼 수 있다. 빌드 자동화 도구나 테스트를 돌리거나, 서버를 띄워준다. Running은 현재 프로세스가 실행 중이라는 뜻이다. 매번 터미널에서 서버를 띄우는 과정을 반복할 필요 없이 한번 설정해두면 이맥스 안에서 간단하게 프로세스를 실행하거나 끄거나 재실행하게 된다. 컴파일이나 등등 터미널에서 할 수 있는 모든 것을 자동화할 수 있다. 단축키를 통해 해당 프로세스의 터미널 출력내용을 확인하는 것도 가능하다.


### 편집중 버퍼상의 빠른 이동: [swiper](https://github.com/abo-abo/swiper)(스와이퍼), [avy](https://github.com/abo-abo/avy)(에이비)

편집시 버퍼 안에서 혹은 버퍼 간의 빠른 이동을 위해 스와이퍼나 에이비를 사용한다. 코드 안에서의 축지법이라고나 할까? 스와이퍼는 검색어를 입력하면 검색된 라인을 미니 버퍼에 띄워주고 선택해 빠르게 이동할 수 있게 해주고 에이비는 실행 후 문자를 1개 혹은 2개를 입력하면 그 문자로 시작하는 라인 혹은 단어들 위에 임시 단축키를 보여주고 해당 단축키를 입력하면 빠르게 이동할 수 있게 해준다.

swiper를 이용해 현재 버퍼 내에서의 이동

![12](https://user-images.githubusercontent.com/389021/32718972-27fead14-c8a2-11e7-80ba-4970b024d4fd.gif)

swiper-all을 이용해 열려있는 버퍼들을 포함해서 이동

![13](https://user-images.githubusercontent.com/389021/32718974-28551f6e-c8a2-11e7-8a0b-527f6e479d13.gif)

avy를 통한 이동 

![14](https://user-images.githubusercontent.com/389021/32718976-28b8b722-c8a2-11e7-95c1-dd81224a1df4.gif)

avy를 실행하고 문자를 입력하면 화면상에 문자로 시작하는 이동 가능한 위치가 단축키로 표시되고 그 단축키를 두르면 그쪽으로 이동한다.


### 일괄 편집: iedit [동영상](https://www.youtube.com/watch?v=xne0kS1DfVs)

iedit은 실시간으로 수정 내용이 보이는 일괄 편집 기능이다. 단어 위에서 혹은 텍스트 셀렉션 후 실행하면 버퍼 상에 해당 단어와 동일한 단어가 하일라이트되고 일괄 편집이 가능해진다. 여기에 수정범위를 좁히거나 넓힐 수 있고 버퍼가 너무 크면 수정되는 내용만 압축해서 볼 수도 있다.

단어를 선택하고 거리를 좁혀서 내용 수정하기 

![15](https://user-images.githubusercontent.com/389021/32718977-28e4f396-c8a2-11e7-974e-deba6927ebe1.gif)

수정 범위 선택하기는 단축키로 쉽게 넓히거나 좁힌다. 

![16](https://user-images.githubusercontent.com/389021/32718986-29fc6214-c8a2-11e7-9d34-9167765a2c13.gif)

사실 다른 개발 도구에서도 지원하는 기능이지만 직관적인 이 손맛은 iedit 만한 게 없다.

### 프로젝트 내 grep 후 한개의 버퍼에서 모든 파일 수정: [wgrep](https://github.com/mhayashi1120/Emacs-wgrep)
프로젝타일에서 살펴봤듯 그랩류 프로그램을 이용해 프로젝트 내 파일 내용을 검색할 수 있다. 그랩류 프로그램을 이용해 검색 결과를 버퍼로 만들면 그랩모드의 텍스트 구조로 보여지고 이때 wgrep을 사용할 수 있다. wgrep은 한개의 버퍼로 여러개의 파일을 일괄 편집할 수 있게 해준다. 즉 검색된 결과 버퍼에서 내용을 수정하면 실제 파일에도 적용되게 할 수 있다는 것이다 (!)

우선 검색을 해서 그랩 버퍼로 만들고

![35](https://user-images.githubusercontent.com/389021/32759173-604c75d2-c92b-11e7-8149-a3fff4e7cf6b.gif)

그렙 버퍼에서 wgrep을 활성화(C-c C-p)하고 내용을 수정한 뒤 저장(C-x C-s)한다. 편의상 각 파일들을 미리 열어두었다.

![36](https://user-images.githubusercontent.com/389021/32759174-60c1763e-c92b-11e7-93d1-67620eb1dd45.gif)

그리고 그랩버퍼도 텍스트 버퍼기 때문에 당연히 iedit을 사용해 일괄로 변경도 가능하다.

![37](https://user-images.githubusercontent.com/389021/32759175-60fab39a-c92b-11e7-9900-f1e1ee636fb6.gif)

나는 여기서 감동을 할 수 밖에 없었다.

### 자동 완성: [Company-mode](http://company-mode.github.io/)(컴패니모드)

이맥스는 자체적으로 Autocomplete(오토컴플릿)이란 자동 완성 도구를 내장하고 문제없이 동작하지만 컴패니는 오토컴플릿보다 설정이 쉬운 편이라 컴패니모드를 사용하기도 한다. 주로 자동 완성은 자체적으로 지원하는 백 엔드도 있지만 언어별로 유용한 정보를 제공하기 위해 메이저 모드 혹은 추가적인 도구를 이용해 자동 완성 백 엔드를 구성한다.(쉽다.) 동적 타이핑을 사용하는 자바스크립트 같은 경우는 [ternjs](http://ternjs.net/)를 이용하면 타입 추론을 통해 정확한 자동 완성을 구현할 수 있다.

![18](https://user-images.githubusercontent.com/389021/32718981-298f13bc-c8a2-11e7-98f0-97ab8791bfa2.gif)

### 정적 분석: [flycheck](http://www.flycheck.org/en/latest/)(플라이첵)

정적 분석 도구와의 연동은 플라이첵을 사용한다. 기본적으로 이미 설정이 잘 되어 있어 외부 도구가 정상적으로 설치만 되어 있다면 특별한 작업 없이 연동이 된다. 자바스크립트의 경우 ESLint를 주로 쓰는데 ESLint가 글로벌로 설치되어 있어야 정상적으로 동작하지만 약간의 작업만 해주면 로컬 모듈로도 사용할 수 있다.

![17](https://user-images.githubusercontent.com/389021/32718979-293aca96-c8a2-11e7-8ce3-841f4eb30890.gif)

### 터미널: multi-term(멀티텀)

에디터 내에서의 터미널은 빔도 가능하지만 사실 빔은 정말 억지로 넣은 느낌이라 보통 사용하지 않는다. 하지만 이맥스에서의 터미널은 딱 사용하기 좋다. 자체적으로 내장된 쉘 모드가 있지만 터미널을 여러 개 관리하기 편한 멀티텀을 추천한다. 멀티텀은 터미널을 여러 개 열어두고 사용할 때는 필수다.

![19](https://user-images.githubusercontent.com/389021/32718957-262ca81a-c8a2-11e7-8872-304dda20d2cd.gif)


### 단축키 치트시트: [which-key](https://github.com/justbur/emacs-which-key)(위치키)

이맥스는 마우스를 사용할 수 있지만 기본적으로는 키보드 기반의 에디터기 때문에 모든 것을 키보드로 컨트롤할 수 있다. 물론 마우스에 손이 덜 가는 부분은 장점이지만 그만큼 단축키가 많아지는 단점도 있다. 사실 이맥스 환경은 함수를 기반으로 확장되기 때문에 함수를 검색하는 기능을 켜서(메타키+x) 하고 싶은 작업을 검색해도 되지만 보통은 단축키를 사용한다. 이맥스의 단축키는 다른 에디터처럼 C-c 이렇게 한 번의 입력으로도 가능하지만 이렇게 단타의 단축키 입력은 이맥스의 모든 기능을 커버하기에는 부족하다. 그래서 이맥스는 단축키의 조합을 사용한다. 예를 들면 C-c를 누르고 p를 누르고 f를 누르면 커맨드가 실행되는 것이다. 이런것을 키 시퀀스라고 한다. 위치키는 이 키 시퀀스의 치트시트를 제공한다. C-c를 누르면 다음에 입력될 수 있는 키를 설명과 함께 보여준다. 그리고 p를 누르면 또 다음에 입력할 수 있는 내용을 보여준다. 그래서 특별히 모두 외우지 않아도 필요한 기능을 쉽게 찾아갈 수 있다. 특별히 설정은 필요 없다. 그냥 위치키가 알아서 해준다.

![20](https://user-images.githubusercontent.com/389021/32718958-26550864-c8a2-11e7-8e28-48d663e924a3.gif)

## 이맥스 어플리케이션

이맥스에 대한 수식어로는 너무 식상한 말이지만 이맥스는 그 자체로 플랫폼이자 OS기 때문에 응용 프로그램을 만들어 사용할 수 있다. 그리고 많은 훌륭한 프로그램이 있는데 그 중 대표적인 두 가지만 소개한다.


### 최고의 git 클라이언트: [Magit](https://magit.vc/)

매깃은 깃 클라이언트다. 사용하고 한번 익숙해지면 더 이상 다른 클라이언트는 생각하지 않게 되는 그런 마성의 클라이언트다. 개인적으로는 깃 같이 중요한 프로그램은 추가적인 도구 말고 기본 도구만 사용하는 것을 선호하는데 매깃은 기본 도구를 편리하게 확장한 느낌이다.

매깃의 기본 화면

![21](https://user-images.githubusercontent.com/389021/32718959-26801ad6-c8a2-11e7-89ec-5cd271f08b7e.png)

깃에 대한 지식만 있다면 매깃을 사용할 때는 "?" 느낌표 단축키만 기억하면 된다. 느낌표를 누르면 마치 위치키처럼 밑에서 팝업이 열리며 사용할 수 있는 작업의 목록과 단축키가 표시되기 때문이다.

![22](https://user-images.githubusercontent.com/389021/32718969-277b9c12-c8a2-11e7-86dc-f775dd1815be.png)

처음 나오는건 작업의 카테고리이고 여기서 단축키를 누르면 세부 작업 목록이 표시된다. 예를 들어 커밋을 하고 싶을때는 Committing의 "c" 버튼을 누르면

![23](https://user-images.githubusercontent.com/389021/32718971-27cf3822-c8a2-11e7-8411-50a2e89b2ea2.png)

이렇게 커밋용 세부 메뉴가 나오게 된다. 여기서 Commit의 "c" 버튼을 누르면

![24](https://user-images.githubusercontent.com/389021/32718973-2829fafa-c8a2-11e7-99ca-a5ce92b4b0c6.png)

커밋 내용을 확인할 수 있는 창과 커밋 메세지를 입력할 수 있는 창이 나온다. 그동안 커맨드라인에서 익숙한 모습으로 보이기 때문에 무리 없이 직관적으로 사용할 수 있다. 보통 미리 매뉴얼을 보지 않고 이런 과정을 통해 쉽게 학습할 수 있다. 매깃은 깃의 모든 기능을 커버하고 있기 때문에 간단하게 소개 정도만 하고 전반적인 기능을 살펴보는 짧은 동영상 하나를 첨부한다.

[Emacs Rocks! Episode 17: Magit](https://www.youtube.com/watch?v=rzQEIRRJ2T0)(2분 39초)


### 일정관리 및 문서작성: [Org-mode](http://orgmode.org/)

오그모드는 오그모드를 사용하려고 이맥스를 배울 정도로 뛰어난 확장성과 기능, 그리고 오랜 기간에 걸친 개발로 안정성까지 갖춘 프로그램이다. 문서작성과 일정을 관리하는 프로그램인데 이 문서도 오그모드에서 작성했다. 오그모드의 문서 포맷은 기본적으로는 마크다운과 같은 텍스트인데 일반 텍스트 에디터에서도 쉽게 편집을 할 수 있다. 오그모드를 사용하는 사람들 중엔 특별한 포맷이 아닌 일반 텍스트 파일을 사용한다는 점을 높게 평가하기도 한다.

![25](https://user-images.githubusercontent.com/389021/32718975-28808d0c-c8a2-11e7-9478-7bfd46bc9c50.png)

기본적으로는 오그모드의 문서가 위와 같이 보이진 않지만 간단한 확장 프로그램만 설치하면 이렇게 다양한 모습으로 시각적인 효과를 줄 수 있다. Outline을 기반으로 문서를 작성하고 콘텐츠를 쉽게 관리한다.

![26](https://user-images.githubusercontent.com/389021/32718978-290eec1e-c8a2-11e7-9588-00336ebb361b.gif)

바벨이란 기능을 이용하면 문서 안에서 특정 코드를 실행하고 결과까지 볼 수 있어 언어를 공부하거나 할 때는 이만한 도구가 없다. 웬만한 언어들은 이미 바벨 익스텐션이 만들어져 있다.

![27](https://user-images.githubusercontent.com/389021/32718980-29649ec0-c8a2-11e7-9414-ad88c071ce2f.gif)

그밖에 문서를 만들면 바로 PT 화면으로 만들어주는 Reveal도 있고 이렇게 만든 오그문서를 HTML이나 doc혹은 마크다운등 다른 문서로 익스포트도 쉽게 가능하다. 오그모드를 이용해 책을 쓰는 사람도 많이 있는 것으로 알고 있다. 오그모드는 테이블 관리에도 능해 엑셀과 같은 사용성으로 텍스트 기반의 스프레드시트로 사용할 수도 있다. 개인적으로는 많이 사용하지 않지만, 기업의 비용 관리나 개인 금전 관리를 오그모드로 하는 경우도 많이 있는 것으로 알고 있다. 하지만 무엇보다도 오그모드는 문서 도구뿐 아니라 일정을 관리하는 도구로도 사용할 수 있다. 필자는 오그모드를 이용해 프로젝트 관리부터 개인 일정까지 관리하는데 매우 만족하면서 사용하고 있다.

일정을 만들어 보자.

![28](https://user-images.githubusercontent.com/389021/32718954-25dabd70-c8a2-11e7-9918-9880180ad4cd.gif)

보통 프로젝트당 한 개의 오그문서를 만들어 일정을 관리한다. 아래는 이맥스 모드를 개발하는 개인 사이드 프로젝트의 오그 문서다. 할 일들과 아이디어 그리고 노트들을 한 문서에서 관리하게 된다. 여담이지만 사이드 프로젝트를 진행할때는 작업을 끝내기 전에 항상 다음 할일을 만들어 둬야 완성율이 높아진다.(물론 사이드 프로젝트는 완성자체가 목적이 아닐 수 있지만..)

![29](https://user-images.githubusercontent.com/389021/32718955-26031680-c8a2-11e7-85ad-357217c25510.png)

심지어 작업하던 소스코드에 링크를 만들어 오그모드 할 일에 링크로 걸 수도 있다. 텍스트파일이라면 어디든 링크를 만들 수 있다.

![29](https://user-images.githubusercontent.com/389021/32718963-2701b42e-c8a2-11e7-94ec-a023c5f5e4ce.gif)

나름 GTD 매니아라 여러 일정 관리 도구를 사용해왔는데(Omnifocus, things, Wunderlist, Todoist 등등) 기능적으로나 확장성으로나 단연 최고라고 생각한다. 다만 모바일 앱이 있긴 하지만 그렇게 좋은 편이 아니라 모바일과의 연동이 불편하지만 업무를 관리할 때 컴퓨터 앞에 없는 경우는 거의 없을거라고 판단했다. 그래서 옴니포커스를 보조적인 도구로 사용한다. 이동 시 떠오르는 할 일이라던지 아이디어는 옴니포커스에 저장해두었다가 나중에 컴퓨터 앞에서 오그모드로 옮겨둔다. 옴니포커스는 오그모드를 사용하기 바로 전까지 사용했던 GTD 도구로 v1, v2 모두 아이폰 앱과 맥앱을 구입해서 사용했었다. 비싸다 :(

집과 회사에서의 오그문서 싱크는 gitlab의 개인 깃리포를 만들어 관리한다.(무료) gitlab도 그렇지만 github도 오그모드 문서를 지원하고 있어 문서를 업로드하면 텍스트가 아닌 이쁘게 포맷된 형태로 보여준다. 프로그래밍 코드의 경우도 신택스하일리이팅까지 된다. README.md대신 README.org를 사용할 수도 있다

오그모드는 십여년동안 개발한 도구다 보니 매뉴얼이 책 한 권이 나올 정도로 기능이 많다.


## 마치며

이글은 이맥스에 대한 전반적인 소개를 해보고자 작성했다. 물론 이맥스를 배우는 것은 녹록지 않다. 일부러 어렵게 느껴질 부분은 생략하기도 했다. 이맥스의 모든 것을 소개한 것은 아니지만 나름 시선을 끌만한 내용들을 담아보려 했다. 그저 한국에 이맥스 사용자가 한 명이라도 더 늘었으면 하는 심정에서다. 빔에 익숙한 분들이라면 빔과 이맥스의 장점을 잘 살린 [spacemacs](http://spacemacs.org/)도 고려해볼 수 있다. 다른 이맥스 유저와 마찬가지로 필자 역시 이맥스 설정파일관리를 깃헙을 통해 하고 있다. Clojure, Emacs, Swift, C# 혹은 프론트엔드 개발자라면 설정을 참조해서 시작하는것도 나쁘지 않을것 같다. ([필자의 설정 깃헙](https://github.com/shiren/dotfiles/blob/master/emacs.d/init.el))
이맥스를 처음 시작하게 되면 다른 에디터에서 익숙하던 기능들을 위주로 배우게 되는데 그러다 보면 이맥스만의 기능들을 알게 되고 결국 이맥스에서 되는 것들이 다른 에디터에서는 되지 않아 다른 에디터를 쓸 수 없게 된다. 이맥스는 무료다. [자 시작해보자!](https://www.gnu.org/software/emacs/tour/)
