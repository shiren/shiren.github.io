{"componentChunkName":"component---src-templates-post-tsx","path":"/2015-02-22-유닛테스트가-해야할-5가지-답변---테스트를-잘-작성하는-방법/","result":{"data":{"markdownRemark":{"html":"<h3>유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법</h3>\n<blockquote>\n<p>원문<br>\n<a href=\"https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d\">https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d</a></p>\n</blockquote>\n<br>\n<h2>대부분의 개발자들은 어떻게 테스트 해야하는지 모른다.</h2>\n<p>모든 개발자들을 프로덕션으로 디플로이할 때 발생할 수 있는 결함을 방지하기 위해 유닛 테스트를 해야 한다고 알고 있지만,\n대부분의 개발자들은 유닛 테스트의 필수적인 요소를 모른다.</p>\n<p>내가 보아온 유닛 테스트의 실패 사례는 셀 수가 없다.\n무엇이 잘못되는 건지 혹은 왜 이게 무슨 문제가 되는 것인지 뿐만 아니라 정확히 개발자가 무엇을 테스트하기 위한 것인지 조차 쉽게 알 수가 없었다.</p>\n<p>최근 프로젝트에서 테스트의 목적이 무엇인지에 대해 전혀 설명이 없는 거대한 양의 유닛 테스트를 만들어 내게 됐다.\n우린 훌륭한 팀이었기에 나는 경계를 늦추고 있었던 것이다. 그 결과 아직도 그 테스트를 작성한 사람만 이해할 수 있는 거대한 양의 유닛 테스트를 갖고 있다.</p>\n<p>다행히 우리는 전체적으로 API를 다시 설계했고 모든 테스트들을 버리고 바닥부터 다시 시작했다.\n그렇지 않았다면 테스트 코드를 다시 작성하는 일이 나의 최우선 과제였을 것이다.</p>\n<p>이 일이 당신에게도 일어나지 않도록 해야한다.</p>\n<br>\n<h2>왜 이런 테스트 규칙이 필요한걸까?</h2>\n<p>당신의 테스트는 소프트웨어의 결함을 방어하는 처음이자 최선의 라인이다.\n테스트는 linting이나 정적 분석보다도 더 중요하다. (정상적인 프로그램 로직에 아무런 문제가 없는 서브클래스의 오류들만 찾아낸다)\n테스트는 그 구현만큼 중요하다. (중요한 것은 코드는 요구 사항이 있고, 그것이 제대로 구현되어 있지 않다면 그것이 어떻게 구현되었는지는 중요하지가 않다.)</p>\n<p>유닛테스트는 어플리케이션을 성공으로 이끌 당신의 비밀무기가 될 많은 기능들을 가지고 있다.</p>\n<ol>\n<li><strong>디자인을 돕는다</strong>: 테스트를 작성한다는 것은 이상적인 API 디자인을 위한 명확한 시각을 제공한다.</li>\n<li><strong>기능을 문서화한다</strong>: 테스트 디스크립션은 그 코드에 모든 요구사항에 대한 구현을 표현하고 있다.</li>\n<li><strong>개발자의 이해를 테스트한다</strong>: 개발자가 모든 치명적인 구성요소의 요구사항들을 코드로 명확히 작성하기에 충분히 문제를 이해하고 있는가?</li>\n<li><strong>품질을 보증(QA)한다</strong>: 수동적인 QA는 오류를 범할 수 있다. 내 경험에 비춰보면 리팩토링을 하거나 새 기능 추가 혹은 제거할 때 여파가 있을 수 있는 모든 기능들을 기억해내서 테스트하는 것은 불가능하다.</li>\n<li><strong>지속적인 배포가 된다</strong>: 자동화된 QA는 프로덕션으로 배포되기 전에 잘못된 빌드가 배포 되는 것을 막아준다.</li>\n</ol>\n<h4>The Science of TDD</h4>\n<ul>\n<li>TDD는 버그의 발생 횟수를 줄여준다.</li>\n<li>TDD는 더욱 모듈화된 디자인이 되도록 도와준다.(소프트웨어이 민첩도와 팀의 속도를 개선해 준다.)</li>\n<li>TDD는 코드의 복잡도를 감소시켜 준다.</li>\n</ul>\n<p>TDD가 효과가 있다는 의미있고 경험적인 증거들은 충분히 있다.</p>\n<br>\n<h2>테스트를 먼저 작성해라.</h2>\n<p>Microsoft Research, IBM, Springer의 test-first와 test-after의 효율성에 대한 연구들에 의하면\n일관적으로 test-first가 테스트를 나중에 추가하는 것보다 더 좋은 결과를 가져온다고 한다.\n확실하게 말할 수 있다. 구현하기 전에\n테스트 먼저 작성해라.</p>\n<blockquote>\n<p>구현을 작성하기 전에 테스트를 먼저 작성해라.</p>\n</blockquote>\n<br>\n<h2>좋은 유닛테스트는 무엇인가?</h2>\n<p>자 TDD는 효과가 있다는게 입증되었다. 테스트를 먼저 작성하고 더 훈련하고, 이 과정을 믿는다. 알겠다.\n그러나 어떻게 좋은 테스트를 작성하는것인가?</p>\n<p>우리는 그 과정을 알아보기위해 실제 프로젝트의 간단한 예제를 살펴볼 것이다.\nStamp 구현의 'compose()' 펑션이다.</p>\n<p>그리고 테스트 프레임웍으로는 tape을 이용할 것이다 tape은 굉장히 명확하고 필수적인 기능들만 심플하게 가지고 있다.</p>\n<p>어떻게 좋은 유닛테스트를 작성할수 있는가에 대해 대답할 수 있기 전에, 먼저 어떻게 유닛테스트가 쓰이게 되는지 이해 할 필요가 있다.</p>\n<ul>\n<li><strong>디자인(API)을 돕는다</strong>: 구현보다 먼저 디자인 단계에 작성된다.</li>\n<li><strong>기능 문서화 및 개발자의 이해에 대한 테스트</strong>: 테스트는 테스트될 기능에 대한 명확한 설명이 제공되야 한다.</li>\n<li><strong>QA/지속적인 배포</strong>: 테스트는 배포 중에 에러시 배포를 중단시키고 좋은 버그 리포트를 제공한다.</li>\n</ul>\n<br>\n<h2>유닛 테스트를 버그 리포트로 활용</h2>\n<p>테스트가 실패하게되면 테스트 리포트는 어떤게 잘못되었는지 단서를 제공한다. 근본적인 원인을 빠르게 찾아내는 비밀은\n어디서 살펴보기 시작해야하는지를 아는 것이다. 그 과정은 명확한 버그리포트를 얻게된다면 훨씬 쉬워질 것이다.</p>\n<blockquote>\n<p>실패한 테스트는 고퀄리티의 버그 리포트가 될 수 있다.</p>\n</blockquote>\n<h4>좋은 테스트 실패 버그 리포트에는 무엇이 있는가.</h4>\n<ol>\n<li>무엇을 테스트 했는가?</li>\n<li>무슨 일을 하는가?</li>\n<li>아웃풋이 무엇인가? (혹은 실질적인 동작)</li>\n<li>아웃풋이 무엇이어야 했는가? (혹은 기대되는 동작)</li>\n</ol>\n<p>좋은 실패 리포트의 예\n<img src=\"https://cdn-images-1.medium.com/max/1400/1*jhYZ6dcMUKAhFyhsWJ6qGg.png\" alt=\"좋은 실패 리포트의 예\"></p>\n<h4>\"무엇을 테스트하는가?\"에 대한 대답으로 시작한다.</h4>\n<ul>\n<li>컴포넌트의 어떤 측면을 테스트하는가?</li>\n<li>기능은 어떤 일을 해야하는가? 어떤 특정한 요구사항을 테스트하는가?</li>\n</ul>\n<p>'compose()'함수는 다수의 스탬프(조합 가능한 팩터리 펑션)를 입력받아 새로운 스탬프를 만든다.\n이 테스트를 작성하기 위해서는 단일 테스트의 최종 목표(요구사항에 대한 테스트)에서부터 거꾸로 작업하게 될 것이다.\n이 테스트를 패스하기 위해 어떤 코드를 작성해야 할까?</p>\n<h4>기능이 어떤 일을 하는가?</h4>\n<p>나는 스트링을 작성하는 것으로 시작하는 것을 좋아한다. 어떤 펑션에도 전달되지 않고 아무 것에도 대입되지 않은 채로 말이다.  단지 명확하게 컴포넌트가 만족해야하는 특정한 요구사항에 집중한다. 지금의 경우는 'compose()' 펑션이 펑션을 리턴해야하는 사실로 부터 시작한다.</p>\n<p>단순하고 테스트 가능한 요구사항:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&#39;compose() should return a function&#39;</code></pre></div>\n<p>그리고 몇가지 부분을 스킵하고 테스트의 나머지 부분을 구체화한다. 이 스트링은 우리의 목표가 되어 미리 우리가 얻어 내야할것에 집중하게 해준다.</p>\n<h4>컴포넌트의 어떤 측면을 테스트 하는가?</h4>\n<p>\"컴포넌트 측면\"은 테스트별로 다양할것이고 이것은 컴포넌트를 테스트하는 적합한 커버리지에 따라 필요한 양이 결정될것이다.</p>\n<p>지금의 경우는 'compose()' 펑션의 리턴타입을 테스트해 제대로된것을 리턴하는지를 확인할것이고 반대로 아무것도 리턴을 안하거나 undefined를 리턴하는지를 확인할것이다.</p>\n<p>이 내용을 질문으로 바로 테스트 코드에 작성해보자. 대답은 테스트의 설명으로 들어간다. 이 단계에서 테스트를 위한 펑션을 실행하고 콜백을 넘겨 테스트러너가 테스트 할때 실행할수 있게한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;컴포넌트의 어떤 측면을 테스트하지?>'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>지금 우리는 compose 함수의 리턴값을 테스트한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Compose함수의 리턴 타입'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그리고 콜백안에서 첫번째 테스트의 설명이 들어가게된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Compose함수의 리턴 타입'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n     <span class=\"token string\">'compose()는 함수를 리턴한다'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<h2>아웃풋이 무엇인가?(예측한 아웃풋과 실제 아웃풋)</h2>\n<p>'equal()'은 내가 좋아하는 assertion이다. 만약에 'equal()'만이 모든 테스트에서 유일한 assertion이라면 거이 대부분의 이세상의 테스트는 더 나아질것이다. 왜냐면?</p>\n<p>'equal()'는 유닛테스트가 답변해야할 제일 중요한 2가지 질문에 답변하기 때문이다.</p>\n<ul>\n<li>실제 아웃풋이 무엇인가?</li>\n<li>아웃풋이 무엇이어야 했는가?</li>\n</ul>\n<p>만약 이 두가지 질문에 대답을 하지못한다면 제대로 테스트를 하지 못한것이다.\n다른것은 몰라도 이것한가지만은 꼭 기억하라</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> Equal은 당신의 새로운 기본 assertion이고 이것은 좋은 테스트의 열쇠가 될것이다.</code></pre></div>\n<p>강력한 기능을 가진 대부분의 assertion 라이브러리들의 다양한 assertion들은 테스트의 질을 떨어뜨린다.</p>\n<h4>도전</h4>\n<p>유닛테스트를 더 잘 작성하고 싶은가? 앞으로는 모든 테스트의 assertion 으로 'equal()'이나 'deepEqual()'을 사용해봐라 (아니면 당신 선택한 라이브러리중 가장 비슷한것) 테스트에 해가 되지 않을까 걱정하지 않아도 된다. 장담컨데 이런 연습이 극적으로 도움이 될것이다.</p>\n<p>코드에서는 어떻게 보일까?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;아웃풋이 무엇인가?>'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;아웃풋이 무엇이어야 했는가?>'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>테스트 실패시 첫번째 질문은 사실 두가지 의무를 가지고있다. 질문에 대답을 코드로 완성하는것으로 두번째에 대한 답변이 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;어떻게 테스트를 재현할까?>'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//how is the test reproduced?</span></code></pre></div>\n<p>여기서 중요한점은 'actual' 값이 어떤 컴포넌트의 public api에 의해 만들어진 값이라는것이다. 그렇지 않다면 이 테스트는 값어치가 없다. 나는 각종 목업과 스텁으로 도배되어 정작 테스트해야할 코드는 거쳐지지 않은 테스트들을 많이 봐왔다.</p>\n<p>리턴값을 확인해보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>assertion을 작성할때 'atucal' 이나 'expected'라는 로컬 변수를 꼭 사용하지 않아도 된다. 하지만 나는 최근에 나의 모든 테스트에 이런 로\n컬변수들을 사용하기 시작했다. 이런 로컬변수를 이용하면 테스트를 읽기 수훨해진다는것을 알아냈기때문이다.</p>\n<p>assertion이 얼마나 명확해지는지 확인해볼까?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>actual<span class=\"token punctuation\">,</span> expected<span class=\"token punctuation\">,</span> <span class=\"token string\">'compose() should return a funtion'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 하면 \"어떻게\"와 \"무엇\"을 테스트 코드에서 분리해 낼 수 있다.</p>\n<ul>\n<li>어떻게 결과를 얻어냈는지 알고 싶을 때는 변수 대입문을 살펴보면 된다.</li>\n<li>무엇을 테스트했는지를 알고싶을 때는 assertion의 설명을 보면 된다.</li>\n</ul>\n<p>이제 결과적으로 테스트 자체가 고퀄리티의 버그 리포트가 되었다.</p>\n<p>전체 테스트 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> test <span class=\"token keyword\">from</span> <span class=\"token string\">'tape'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> compose <span class=\"token keyword\">from</span> <span class=\"token string\">'../source/compose'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Compose function output type'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>actual<span class=\"token punctuation\">,</span> expected<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'compose() should return a function.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이제부터 테스트를 작성할 때는 테스트가 다음 질문에 모두 답변을 해야 한다는 것을 명심했으면 한다.</p>\n<ol>\n<li>무엇을 테스트하는가?</li>\n<li>테스트할 대상이 무엇을 해야 하는가?</li>\n<li>아웃풋이 무엇인가?</li>\n<li>아웃풋이 무엇이어야 했는가?</li>\n<li>어떻게 테스트가 재현될 수 있을까?(How can the test be reproduced?)</li>\n</ol>\n<p>마지막 질문에 대한 대답은 'actual' 값을 얻어오는 부분에서 확인할 수 있다.</p>\n<h4>유닛테스트 템플릿</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> test <span class=\"token keyword\">from</span> <span class=\"token string\">'tape'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// For each unit test you write,</span>\n<span class=\"token comment\">// answer these questions:</span>\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'What component aspect are you testing?'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token string\">'What is the actual output?'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'What is the expected output?'</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>actual<span class=\"token punctuation\">,</span> expected<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'What should the feature do?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>유닛 테스트를 잘 사용하는 방법은 많이 있다. 하지만 테스트를 잘 작성하는 방법을 아는 것이 더 중요하다.</p>","fields":{"slug":"/2015-02-22-유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법/"},"excerpt":"유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법 원문\nhttps://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d 대부분의 개발자들은 어떻게 테스트 해야하는지 모른다. 모든 개발자들을 프로덕션으로 디플로이할 때 발생할 수 있는 결함을 방지하기 위해 유닛 테스트를 해야 한다고 알고 있지만,\n대부분의 개발자들은 유닛 테스트의 필수적인 요소를 모른다. 내가 보아온 유닛 테스트의 실패 사례는 셀 수가 없다.\n무엇이 잘못되는 건지 혹은 왜 이게 무슨 …","frontmatter":{"title":"유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법","date":"24 September, 2015","categories":"javascript, test, translation"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-06-15-유용한테스트케이스를위한개발자의자세/"},"frontmatter":{"title":"유용한 테스트 케이스를 위한 개발자의 자세","categories":"test, tdd, unittest","date":"15 June, 2020"},"excerpt":"각종 커뮤니티에 주기적으로 등장하는 \"private 메서드를 테스트하려면 어떻게 하나요?\" 혹은 \"private 메서드를 테스트해야 하나요?\" 와 같은 질문을 보면서 언젠가는 관련해서 정리해봐야겠다고 생각했었는데 꽤 시간이 흘러 이 내용으로 글을 써본다. 주제 자체는 간단한 편이지만 사람마다 생각이 다른 것 같다. 특히 해외 개발자들의 의견이 분분한 것 같다. 사실 이 문제는 효과적인 테스트 케이스(이하 TC)란 무엇인가란 질문과 비슷하다. private 메서드는 객체지향적인 관점에서 생각한 것이고 노출된 함수 내부에서 접근하는,…"},{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript, ecmascript, private","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-07-10-요즘 잘나가는 프론트엔드 개발환경 만들기(2018) ES6/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6","categories":"javascript, frontend","date":"10 July, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6 본 시리즈의  이전 아티클에서는 웹팩4에 대해 다루면서 바로 쓸 수 있는 환경을 만들어봤다. 이번편에는 그 환경 그대로 이용해 ES6 개발 환경을 추가한다. ES6는 이제 충분히 써도 될만한 시기라고 생각한다. \"나는 프런트 개발자가 아니기도 하고 브라우저가 모두 지원하지도 않기에 ES6는 아직 못쓴다\" 라고 생각하고 있다면 이 글을 통해 생각을 바꿀 수 있길 바란다. 어차피 쓰는 거 ES6뿐 아니라 ES8까지 사용하는 것을 권장한다. IE11 이하 버전들은 ES6나 이…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2020-06-15-유용한테스트케이스를위한개발자의자세/"},"frontmatter":{"title":"유용한 테스트 케이스를 위한 개발자의 자세","categories":"test, tdd, unittest","date":"15 June, 2020"},"excerpt":"각종 커뮤니티에 주기적으로 등장하는 \"private 메서드를 테스트하려면 어떻게 하나요?\" 혹은 \"private 메서드를 테스트해야 하나요?\" 와 같은 질문을 보면서 언젠가는 관련해서 정리해봐야겠다고 생각했었는데 꽤 시간이 흘러 이 내용으로 글을 써본다. 주제 자체는 간단한 편이지만 사람마다 생각이 다른 것 같다. 특히 해외 개발자들의 의견이 분분한 것 같다. 사실 이 문제는 효과적인 테스트 케이스(이하 TC)란 무엇인가란 질문과 비슷하다. private 메서드는 객체지향적인 관점에서 생각한 것이고 노출된 함수 내부에서 접근하는,…"},{"fields":{"slug":"/2020-03-24-개발자와명상/"},"frontmatter":{"title":"개발자와 명상","categories":"life, meditation, productivity","date":"24 March, 2020"},"excerpt":"언젠가부터 여러 가지 걱정들로 머릿속이 복잡해지고 있었다. 이런 상황에서는 운동과 독서가 해결책이 될 수 있는데 운동은 평소 꾸준히 하는 편이었고 독서량을 많이 늘려봤다. 기술 서적이 아닌 내 삶에 필요하다고 생각하는 주제의 책들을 읽었다. 하지만 뭔가 부족했다. “생각을 정리할 시간이 필요하다.”라고 생각했지만, 막상 생각을 정리할 시간을 내기 힘들었다. 지금 생각해보면 그게 힘들었던 건지 생각을 직접적으로 대면하기 두려웠었는지 모르겠다.  몸뚱아리는 현재에 있었지만, 정신과 생각은 미래와 과거를 수없이 오갔다.  마음이 평화롭…"},{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript, ecmascript, private","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"}]}},"pageContext":{"slug":"/2015-02-22-유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법/","categoriesRegex":"/javascript|test|translation/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}