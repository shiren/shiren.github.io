{"componentChunkName":"component---src-templates-post-tsx","path":"/2015-08-03-자바스크립트에서의-커링/","result":{"data":{"markdownRemark":{"html":"<h1>자바스크립트의 커링</h1>\n<p>Currying in Javascript</p>\n<blockquote>\n<p>원문<br>\n<a href=\"https://medium.com/@kevincennis/currying-in-javascript-c66080543528\">https://medium.com/@kevincennis/currying-in-javascript-c66080543528</a></p>\n</blockquote>\n<br>\n<h2>자바스크립트에서의 커링</h2>\n<p>최근 나는 함수형 프로그래밍에 대해 많은 생각을 해왔다. 함수형 프로그래밍은 일종의 커링함수 만들어가는 과정과 같이 재미있는 것이라 생각했다.<br>\n커링을 모르는 사람을 위해 설명을 하자면<br>\n<strong>커링은 n개의 인자를 가진 함수를 변형하여 하나의 인자를 받는 n개의 함수로 만드는 것</strong>이다.<br>\n각 부분이 적용된 함수들은 체인을 만들게 되고 마지막 체인에서 결국 value를 해결하게 된다.\n아래 커링을 사용하는 간단한 예제가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">volume</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">l<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> l <span class=\"token operator\">*</span> w <span class=\"token operator\">*</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> curried <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> volume <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">curried</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 6</span></code></pre></div>\n<h2>Disclaimer</h2>\n<p>이 포스트는</p>\n<ul>\n<li>클로저</li>\n<li>일급함수</li>\n<li>Function#apply()</li>\n</ul>\n<p>와 같은 것들에 대한 지식이 있다고 가정한다. 만약 당신이 이런 컨셉에 익숙치 않다면 더 읽기 전에 각 내용에 대해 알아 보고 오는게 좋다.</p>\n<h2>커링 함수를 작성하자</h2>\n<p>커링 함수를 구현할 때 제일 처음 떠오르는 생각은 커링할 함수를 인자로 받아야 한다는 것이다. 여기서부터 시작할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 다음으로 우리의 함수가 얼마나 많은 인자를 필요로 하는지 알아야 한다(이것을 \"arity\"라고한다). 이게 아니면, 우리는 언제 새로운 함수를 리턴하게 되고 언제 값을 돌려받을지는 알 수 없다. length 프로퍼티를 이용해 함수가 얼마나 많은 인자가 필요한지를 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서부터 점점 어려워진다.\n기본적으로 커리된 함수가 호출될 때마다 우리는 새로운 인자를 클로저 안의 Array에 추가한다. 만약 커리된 원래 함수가 필요한 인의 개수와 그 Array의 원소의 개가 같게되면  우리는 원래의 함수를 호출하고 아니라면 새로운 함수를 리턴한다.<br>\n그러기 위해서는<br></p>\n<ol>\n<li>우리는 이자의 목록을 소유할 클로저가 필요하고</li>\n<li>전체 인자의 개수를 체크해 부분적으로 적용된 새로운 함수를 리턴하거나</li>\n<li>혹은 모든 인수가 적용된 원래 함수의 결과 값을 리턴하는 함수가 필요하다.</li>\n</ol>\n<p>나는 보통 'resolver'라는 즉시실행 함수로 구현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">resolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>resolver 안에서 처음 해야 할 일은 전달받은 인자의 복사본을 만드는 것이다. memory라는 이름의 변수를 만들고 Array#slice를 이용해서 arguments 객체의 복사본을 만들 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">resolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음으로 resolver는 함수를 리턴해야 한다. 이 함수가 커리된 함수를 호출했을 때 실행되는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">resolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>resolver 내부에서 리턴된 함수가 호출될 때는 인자가 전달이 되어야 하는데 이 인자는 memory라는 변수에 저장될 인자가 될 수도 있다. 그래서 먼저 slice()를 이용해 memory의 카피를 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">resolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> local <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 새로운 인자들을 Array#push를 이용해 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">resolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> local <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span> local<span class=\"token punctuation\">,</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자 이제 우리는 지금까지의 부분 적용된 함수의 체인으로 전달받은 모든 인자들이 담긴 새로운 배열을 얻게 되었다.\n마지막으로 해야 할 일은 전달받은 인자의 개수와 커리된 함수의 arity와 비교해야 한다. 만약 개수가 같다면 우리는 원래 함수를 호출하게 된다. 만약 아니라면 우리는 resolver를 이용해 다른 memory에 저장된 모든 인자를 갖는 다른 함수를 리턴한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">fn</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arity <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">resolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> local <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span> local<span class=\"token punctuation\">,</span> arguments <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      next <span class=\"token operator\">=</span> local<span class=\"token punctuation\">.</span>length <span class=\"token operator\">>=</span> arity <span class=\"token operator\">?</span> fn <span class=\"token operator\">:</span> resolver<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> local <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이해하기 쉽지는 않은 코드일 것이다. 예제를 하나하나 설명하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">volume</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">l<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> l <span class=\"token operator\">*</span> w <span class=\"token operator\">*</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> curried <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> volume <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Okay, curried는 volume을 우리의 커리함수에 인자로 전달해 실행한 결과이다.\n잠깐 되돌아본다면 이때 일어나는 일은 아래와 같다.</p>\n<ol>\n<li>우리는 volume의 arity를 저장한다.(3이다)</li>\n<li>resolver를 인자 없이 즉시 실행한다, memory가 빈 상태라는 의미이다.</li>\n<li>resolver는 무명함수를 리턴한다.</li>\n</ol>\n<p>자 이제는 우리의 커리된 함수를 실행하고 그 결과를 length에 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">volume</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">l<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> l <span class=\"token operator\">*</span> w <span class=\"token operator\">*</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> curried <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> volume <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> length <span class=\"token operator\">=</span> <span class=\"token function\">curried</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>각 과정을 자세히 설명하면,</p>\n<ol>\n<li>여기서 우리가 실행한 것은 정확히 resolver에 의해 리턴된 무명함수이다.</li>\n<li>memory의 복사본을 만들고(비어있었던) 이것을 local이라고 부른다.</li>\n<li>전달받은 인자 (2)를 local 배열에 추가한다.</li>\n<li>local의 개수가 volume의 arity보다 작으니 우리는 이전까지 가지고 있던 인자의 목록과 함께 resolver를 다시 실행한다. 이것은 새로운 클로저에서 새로운 이전에 전달받은 인자(2)를 포함한 새로운 memory 배열을 만든다.</li>\n<li>마침내, resolver는 새로운 클로저와 그 안의 새로운 memory 배열에 접근할 수 있는 새로운 함수를 만들어 리턴한다.</li>\n</ol>\n<p>그래서 다시 우리는 무명함수를 얻게 된다. 그러나 이번에는 memory 객체가 비어있지 않고 (2)라는 인자를 갖고 있게 된다.\n만약 다시 length 함수를 호출하게 되면 이 프로세스가 반복된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">volume</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">l<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> l <span class=\"token operator\">*</span> w <span class=\"token operator\">*</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> curried <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> volume <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> length <span class=\"token operator\">=</span> <span class=\"token function\">curried</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> lengthAndWidth <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>다시 실제로 실행되는 것은 resolver가 리턴한 무명함수이고,</li>\n<li>이번에는 resolver가 이전의 인자들을 가지고 있어 우리는 [2]라는 배열의 복사본을 얻게 된다.</li>\n<li>그리고 새로운 인자인 3을 local 배열에 추가하고,</li>\n<li>여전히 local의 개수가 arity보다 적기 때문에 지금까지 전달된 인자들과 resolver를 이용해 새로운 함수를 리턴한다.</li>\n</ol>\n<p>자 이제는 우리의 lengthAndWidth 함수를 호출해 결과 값을 얻어올 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">volume</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">l<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> l <span class=\"token operator\">*</span> w <span class=\"token operator\">*</span> h<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> curried <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span> volume <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> length <span class=\"token operator\">=</span> <span class=\"token function\">curried</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> lengthAndWidth <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> <span class=\"token function\">lengthAndWidth</span><span class=\"token punctuation\">(</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 24</span></code></pre></div>\n<p>지금부터는 단계가 끝부분에서 약간 달라진다.</p>\n<ol>\n<li>다시 한번 resolver가 리턴한 무명함수가 실행되고,</li>\n<li>이번에도 resolver는 이전 두 개의 인자를 가지고 있어 [2,3]와 같은 배열이 local에 할당된다.</li>\n<li>새로운 인자인 4가 local 배열에 추가되고,</li>\n<li>이번에는 arity와 local의 개수가 같게되어 새로운 함수를 리턴하는 대신 지금까지 쌓아온 인자를 volume에 전달하여 호출해 실행한 결과 값인 24를 얻게 된다.</li>\n</ol>\n<h2>Wrapping up</h2>\n<p>아직까지는 나는 일상적인 작업에서 커링을 꼭 써야 하는 유즈케이스를 찾지는 못 했다. 하지만 나는 이런 함수를 작성하는 과정이 함수형 프로그래밍의 이해도를 높이고 클로저나 1급 함수에 대한 개념을 강화할 수 있을 거라 생각한다.</p>","fields":{"slug":"/2015-08-03-자바스크립트에서의 커링/"},"excerpt":"자바스크립트의 커링 Currying in Javascript 원문\nhttps://medium.com/@kevincennis/currying-in-javascript-c66080543528 자바스크립트에서의 커링 최근 나는 함수형 프로그래밍에 대해 많은 생각을 해왔다. 함수형 프로그래밍은 일종의 커링함수 만들어가는 과정과 같이 재미있는 것이라 생각했다.\n커링을 모르는 사람을 위해 설명을 하자면\n커링은 n개의 인자를 가진 함수를 변형하여 하나의 인자를 받는 n개의 함수로 만드는 것이다.\n각 부분이 적용된 함수들은 체인을 만들게 되고 …","frontmatter":{"title":"자바스크립트에서의 커링","date":"03 August, 2015","categories":"javascript, translation"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-07-10-요즘 잘나가는 프론트엔드 개발환경 만들기(2018) ES6/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6","categories":"frontend, javascript","date":"10 July, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6 본 시리즈의  이전 아티클에서는 웹팩4에 대해 다루면서 바로 쓸 수 있는 환경을 만들어봤다. 이번편에는 그 환경 그대로 이용해 ES6 개발 환경을 추가한다. ES6는 이제 충분히 써도 될만한 시기라고 생각한다. \"나는 프런트 개발자가 아니기도 하고 브라우저가 모두 지원하지도 않기에 ES6는 아직 못쓴다\" 라고 생각하고 있다면 이 글을 통해 생각을 바꿀 수 있길 바란다. 어차피 쓰는 거 ES6뿐 아니라 ES8까지 사용하는 것을 권장한다. IE11 이하 버전들은 ES6나 이…"},{"fields":{"slug":"/2018-04-16-요즘 잘나가는 프론트엔드 개발 환경 만들기(2018) Webpack 4/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발 환경 만들기(2018): Webpack 4","categories":"frontend, javascript","date":"16 April, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발 환경 만들기(2018): Webpack 4 최근에 새로운 프로젝트를 진행하게 되면서 기존에 간만 살짝 보고 있던 뷰(Vue, 이하 뷰)를 본격적으로 도입하게 되었다. 사실 팀에서는 리액트를 선호하고 있었으나 회사 내부에서 뷰의 사용이 빠른 속도로 증가하고 있었고 그에 따라 팀내에서도 뷰에 대한 전문성이 필요하게 되었다. 뷰와 리액트는 서로 영향을 주고받고 발전해나가는 도구들이라 비슷한 부분이 많아 큰 어려움 없이 적응할 수 있었다. 새로운 프로젝트에서는 뷰를 사용하는것 뿐 아니라 다른 개발 환경도 요…"},{"fields":{"slug":"/2017-09-18-웹 기술로 구현하는 Adaptive HTTP Streaming/"},"frontmatter":{"title":"웹 기술로 구현하는 Adaptive HTTP Streaming","categories":"frontend, javascript","date":"18 September, 2017"},"excerpt":"웹 기술로 구현하는 Adaptive HTTP Streaming 한국은 물론 세계적으로 엄청난 양의 동영상 콘텐츠가 소비되고 있다. 플래시가 대세였던 웹 동영상 기술이 점차 표준 기술인 HTML5 비디오로 전환되었고 요즘은 대부분의 동영상 서비스는 HTML5를 기반으로 서비스되고 있다. 동영상 기술은 점차 고도화되어 네트워크 환경에 따른 최적의 동영상 품질을 스트리밍해 버퍼링없는 서비스를 제공하기 위해 여러 방법들이 모색되었고 그중 하나가 새로 프로토콜을 만드는 대신 기존의 HTTP를 이용해 구현하는 Adaptive HTTP Str…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들들은 글을 따로 안 쓰려고 하는 편인…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"},{"fields":{"slug":"/2020-09-07/"},"frontmatter":{"title":"하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세","categories":"productivity, motivation, life","date":"07 September, 2020"},"excerpt":"하루 24시간은 모두에게 공평하지만 그 24시간을 모두가 공평하게 사용하진 않는다. 하루의 여가시간을 어떻게 하면 더 효율적으로 사용할 수 있을까는 나의 오랜 고민거리였다. 단기 목표도 세워보고 장기 목표도 세워보고 포모도로, GTD도 도입하고 간츠도 사용해보고 하루 표준 계획표도 짜보고 일주일 보고서도 만들어봤다. 하루를 온전히 “노력”하기 위한 ”노력”을 많이 했다. 시도했던 것 대부분은 조금씩 달랐지만 주로 나에게 맞는 일상 패턴을 찾는 과정이었다. 개발자로서 회사 업무시간이나 여가 시간, 하루 대부분의 시간을 개발과 관련된…"},{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2020-06-15-유용한테스트케이스를위한개발자의자세/"},"frontmatter":{"title":"유용한 테스트 케이스를 위한 개발자의 자세","categories":"test, tdd","date":"15 June, 2020"},"excerpt":"각종 커뮤니티에 주기적으로 등장하는 \"private 메서드를 테스트하려면 어떻게 하나요?\" 혹은 \"private 메서드를 테스트해야 하나요?\" 와 같은 질문을 보면서 언젠가는 관련해서 정리해봐야겠다고 생각했었는데 꽤 시간이 흘러 이 내용으로 글을 써본다. 주제 자체는 간단한 편이지만 사람마다 생각이 다른 것 같다. 특히 해외 개발자들의 의견이 분분한 것 같다. 사실 이 문제는 효과적인 테스트 케이스(이하 TC)란 무엇인가란 질문과 비슷하다. private 메서드는 객체지향적인 관점에서 생각한 것이고 노출된 함수 내부에서 접근하는,…"}]}},"pageContext":{"slug":"/2015-08-03-자바스크립트에서의 커링/","categoriesRegex":"/javascript|translation/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}