{"componentChunkName":"component---src-templates-post-tsx","path":"/2016-02-15-Webpack으로-자바스크립트-모듈관리-하기/","result":{"data":{"markdownRemark":{"html":"<h3>디펜던시 모듈 관리</h3>\n<p>기존의 프론트엔드 자바스크립트는 특별히 모듈화나 디펜던시관리에 대한 방법이 없어 필요한 자바스크립트 파일을 정해진 순서에 맞게 직접 스크립트 태그로 로드하고 각각 약속된 네임스페이스에 담아 공유했었다. 이런 방식은 프로젝트가 커질수록 그리고 참여 개발자가 많을수록 문제를 일으켰다.</p>\n<p>이후 개발자들에 의해 AMD와 CommonJS 두가지 방법으로 모듈 관리 환경이 발전하게 되었는데,\nAMD 방식은 RequireJS가 많이 사용되고 있고 CommonJS는 Browserify가 인기가 많았다. 그리고 CommonJS는 NodeJS에서 사용하고 있는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//AMD style</span>\n<span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n     ‘module1’<span class=\"token punctuation\">,</span>\n     ‘module2’<span class=\"token punctuation\">,</span>\n     ‘module3’\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>\n     <span class=\"token parameter\">module1<span class=\"token punctuation\">,</span>\n     module2<span class=\"token punctuation\">,</span>\n     module3</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\">//using modules</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//CommonJS style</span>\n<span class=\"token keyword\">var</span> module1 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>‘module1’<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> module2 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>‘module2’<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> module3 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>‘module3’<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//using modules</span></code></pre></div>\n<h3>Webpack이란</h3>\n<p>Webpack은 Requirejs나 Browserify와 같은 자바스크립트 모듈 디펜던시를 관리하는 도구다.\nRequirejs을 꽤 오래전부터 사용해오다 Browserify로 변경해서 사용한 지 1년이 넘었는데, 바꾸게 된 이유는 Requirejs의 AMD방식은 모듈을 로드할때 로드할 모듈 정보를 인자에 넘기고 콜백 함수를 통해 파라메터로 모듈들을 전달받는 구조다 보니 로드하는 모듈이 많아질수록 관리가 힘든 점이 제일 컸으며 점점 NodeJS 코드를 다루는 상황이 많아지고 있어 모듈관리를 한가지 스타일로 유지하고 싶었다.</p>\n<p><img src=\"http://webpack.github.io/assets/what-is-webpack.png\" alt=\"웹팩설명 다이어그램\"></p>\n<p>Browserify를 문제없이 사용하던 중 Webpack 이란 도구를 알게 되었는데, Webpack은 AMD와 CommonJS를 동시에 지원할 뿐 아니라 기본적으로 부분을 캐싱하여 변경점만 번들링하는 방식이라 속도가 빠르고 Karma와 같은 테스트 런너와의 연동도 훨씬 좋았다. 무엇보다 제일 활발하게 진행되는 오픈소스 프로젝트였기에 발전 가능성이 제일 커 보였다. 결과적으로 앞으로 새로 시작하는 프로젝트는 물론 이미 Browserify로 작업된 프로젝트들도 단계적으로 Webpack을 사용할 예정이다</p>\n<h3>설치 및 간단한 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install webpack -g</code></pre></div>\n<p>보통의 nodejs 모듈처럼 npm을 이용해 webpack을 설치한다.\nglobal에 설치하는 것을 예제로 사용했지만 프로젝트별로 따로 설치하는 것을 추천한다.</p>\n<p>index.js라는 엔트리 포인트를 시작으로 내부의 디펜던시가 해결되어 머징된 bundle.js라는 파일을 만들어내는 예제다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack ./src/index.js ./dist/bundle.js</code></pre></div>\n<p>html파일에서 실제로 로드하는 자바스크립트 파일은 bundle.js가 되는것이다.</p>\n<h3>설정파일</h3>\n<p>Webpack을 실행할 때 대부분의 설정은 커맨드 라인에서 직접 파라메터로 설정이 가능하지만 매번 해줄 수 없으니 프로젝트의 설정을 파일로 만들어 간편하게 실행한다.\n<strong>webpack.config.js</strong>란 파일을 만들고 위의 커맨드 라인 예제와 동일한 파라메터를 설정파일로 만들어 보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token operator\">:</span> <span class=\"token string\">\"./src/index.js\"</span><span class=\"token punctuation\">,</span>\n    output<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      filename<span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/bundle.js\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 설정파일을 만들어두면 해당위치에서</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack</code></pre></div>\n<p>파라메터 없이 실행해도 파일에 저장된 설정대로 bundle.js파일을 만들어준다.</p>\n<h3>watch 모드</h3>\n<p>watch 모드는 프로젝트의 js 소스코드가 변경될 때마다 자동으로 다시 bundle.js 파일을 만들어주는 기능을 한다. 개발중에는 주로 watch 모드를 이용하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack -w</code></pre></div>\n<p>Webpack을 <code class=\"language-text\">-w</code> 파라메터를 주고 실행하거나 설정파일에 <code class=\"language-text\">watch:true</code>를 추가한다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/13038853/c523112e-d3db-11e5-8cdf-164866b79bc9.jpeg\" alt=\"0eba1c1616fa0ed9e77075c5ce795ac7\"></p>\n<p>첫 번째 실행 시점에서 Webpack이 종료되지 않고 대기하다가 코드를 수정하면(여기서는 sub.js) <strong>해당 파일만</strong> 다시 bundle.js에 적용된다.\n여기서 중요한 점은 특정 파일의 일부분을 수정해서 저장했는데 전체의 코드를 다시 훑어서 전체의 bundle.js를 다시 만드는것이 캐싱된 상태에서 변경이 일어난 자바스크립트 파일만 변경해 주는 방식이라는 것이다. 그래서 매우 빠르다. Browserify는 이렇게 하려면 추가적인 모듈과 복잡한 설정이 필요했다.그리고 보여주는 터미널 로그도 Browserify보다 이쁘고 필요한 정보를 잘 제공해 준다.</p>\n<h3>로더</h3>\n<p>Webpack은 로더라는 일종의 플러그인들을 이용해 기능을 확장할 수 있다.\nES6와 ES7문법으로 작업하고 바벨 로더를 이용해 번들링 하는 과정에서 결과물을 ES5로 Transpile 할 수 있으며 Uglify 로더를 이용해 코드를 난독화도 할수 있다. 빌드하는 과정을 자동화 하는 도구로 Grunt나 Gulp가 많이 사용되는데 그런 도구들이 해주던 역할을 이 로더들을 이용해서 처리할 수 있다. 필요한 로더는 직접 만들 수 있지만 이미 많은 로더들이 구현되어 있어 바로 사용할 수가 있다. (<a href=\"http://webpack.github.io/docs/list-of-loaders.html\">로더목록</a>)</p>\n<h3>장점</h3>\n<p>모듈 로드 및 디펜던시 관리도구로써의 Webpack의 장점은 아래와 같다.</p>\n<ul>\n<li>관련 도구중 제일 핫하다.</li>\n<li>AMD &#x26; CommonJS 코드 둘다 사용 가능</li>\n<li>큰 어려움없이 RequireJS나 Browserify에서 전환이 가능하다.</li>\n<li>Watch모드의 캐싱으로 개발시 변환속도가 매우 빠르다.</li>\n<li>특별한 자동화도구 없이 로더를 이용해 기능을 확장할 수 있다.</li>\n<li>Karma, Babel등 최신 자바스크립트 도구들과의 연동성이 좋다.</li>\n<li>개발용 서버를 따로 구성할 필요 없이 바로 사용 가능한 <a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">webpack-dev-server</a>가 있다.</li>\n</ul>\n<h3>Quick start!</h3>\n<p>디렉토리를 하나 만들고 설정파일을 만든다. (webpack.config.js)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//webpack.config.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token operator\">:</span> <span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">,</span>\n    output<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        filename<span class=\"token operator\">:</span> <span class=\"token string\">\"bundle.js\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>만들려는 자바스크립트 어플리케이션의 시작점이 되는 index.js파일을 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//index.js</span>\n<span class=\"token keyword\">var</span> sub <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./sub'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsub<span class=\"token punctuation\">.</span><span class=\"token function\">subInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>index.js는 sub라는 모듈이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//sub.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">subInit</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is sub2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>우리가 만들 어플리케이션은 페이지에 로드 되자마자 콘솔에 로그 한 줄을 남긴다.\n이제 모든 게 통합된 번들 파일을 만든다.(컴파일이라고도 할 수 있겠지만 굳이 따지만 링킹과정에 가깝겠다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack</code></pre></div>\n<p>html파일을 만들어 번들파일을 불러온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>X-UA-Compatible<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>IE=edge,chrome=1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>TITLE HERE<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>“./bundle.js”</span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>이제 브라우저에서 html파일을 열어 본다.</p>\n<p>자 이제 어플리케이션에 기능을 더 추가해본다!!</p>\n<p>보다 추가적인 자세한 사용법은 <a href=\"https://webpack.github.io/\">Webpack사이트</a>에서 찾을 수 있다.</p>","fields":{"slug":"/2016-02-15-Webpack으로 자바스크립트 모듈관리 하기/"},"excerpt":"디펜던시 모듈 관리 기존의 프론트엔드 자바스크립트는 특별히 모듈화나 디펜던시관리에 대한 방법이 없어 필요한 자바스크립트 파일을 정해진 순서에 맞게 직접 스크립트 태그로 로드하고 각각 약속된 네임스페이스에 담아 공유했었다. 이런 방식은 프로젝트가 커질수록 그리고 참여 개발자가 많을수록 문제를 일으켰다. 이후 개발자들에 의해 AMD와 CommonJS 두가지 방법으로 모듈 관리 환경이 발전하게 되었는데,\nAMD 방식은 RequireJS가 많이 사용되고 있고 CommonJS는 Browserify가 인기가 많았다. 그리고 CommonJS는…","frontmatter":{"title":"Webpack으로 자바스크립트 모듈관리 하기","date":"15 February, 2016","categories":"frontend, javascript, webpack"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-07-10-요즘 잘나가는 프론트엔드 개발환경 만들기(2018) ES6/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6","categories":"frontend, javascript","date":"10 July, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6 본 시리즈의  이전 아티클에서는 웹팩4에 대해 다루면서 바로 쓸 수 있는 환경을 만들어봤다. 이번편에는 그 환경 그대로 이용해 ES6 개발 환경을 추가한다. ES6는 이제 충분히 써도 될만한 시기라고 생각한다. \"나는 프런트 개발자가 아니기도 하고 브라우저가 모두 지원하지도 않기에 ES6는 아직 못쓴다\" 라고 생각하고 있다면 이 글을 통해 생각을 바꿀 수 있길 바란다. 어차피 쓰는 거 ES6뿐 아니라 ES8까지 사용하는 것을 권장한다. IE11 이하 버전들은 ES6나 이…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"},{"fields":{"slug":"/2020-09-07/"},"frontmatter":{"title":"하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세","categories":"productivity, motivation, life","date":"07 September, 2020"},"excerpt":"하루 24시간은 모두에게 공평하지만 그 24시간을 모두가 공평하게 사용하진 않는다. 하루의 여가시간을 어떻게 하면 더 효율적으로 사용할 수 있을까는 나의 오랜 고민거리였다. 단기 목표도 세워보고 장기 목표도 세워보고 포모도로, GTD도 도입하고 간츠도 사용해보고 하루 표준 계획표도 짜보고 일주일 보고서도 만들어봤다. 하루를 온전히 “노력”하기 위한 ”노력”을 많이 했다. 시도했던 것 대부분은 조금씩 달랐지만 주로 나에게 맞는 일상 패턴을 찾는 과정이었다. 개발자로서 회사 업무시간이나 여가 시간, 하루 대부분의 시간을 개발과 관련된…"},{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"}]}},"pageContext":{"slug":"/2016-02-15-Webpack으로 자바스크립트 모듈관리 하기/","categoriesRegex":"/frontend|javascript|webpack/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}