{"componentChunkName":"component---src-templates-post-tsx","path":"/2016-02-15-Webpack으로-자바스크립트-모듈관리-하기/","result":{"data":{"markdownRemark":{"html":"<h3>디펜던시 모듈 관리</h3>\n<p>기존의 프론트엔드 자바스크립트는 특별히 모듈화나 디펜던시관리에 대한 방법이 없어 필요한 자바스크립트 파일을 정해진 순서에 맞게 직접 스크립트 태그로 로드하고 각각 약속된 네임스페이스에 담아 공유했었다. 이런 방식은 프로젝트가 커질수록 그리고 참여 개발자가 많을수록 문제를 일으켰다.</p>\n<p>이후 개발자들에 의해 AMD와 CommonJS 두가지 방법으로 모듈 관리 환경이 발전하게 되었는데,\nAMD 방식은 RequireJS가 많이 사용되고 있고 CommonJS는 Browserify가 인기가 많았다. 그리고 CommonJS는 NodeJS에서 사용하고 있는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//AMD style</span>\n<span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n     ‘module1’<span class=\"token punctuation\">,</span>\n     ‘module2’<span class=\"token punctuation\">,</span>\n     ‘module3’\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>\n     <span class=\"token parameter\">module1<span class=\"token punctuation\">,</span>\n     module2<span class=\"token punctuation\">,</span>\n     module3</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\">//using modules</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//CommonJS style</span>\n<span class=\"token keyword\">var</span> module1 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>‘module1’<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> module2 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>‘module2’<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> module3 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>‘module3’<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//using modules</span></code></pre></div>\n<h3>Webpack이란</h3>\n<p>Webpack은 Requirejs나 Browserify와 같은 자바스크립트 모듈 디펜던시를 관리하는 도구다.\nRequirejs을 꽤 오래전부터 사용해오다 Browserify로 변경해서 사용한 지 1년이 넘었는데, 바꾸게 된 이유는 Requirejs의 AMD방식은 모듈을 로드할때 로드할 모듈 정보를 인자에 넘기고 콜백 함수를 통해 파라메터로 모듈들을 전달받는 구조다 보니 로드하는 모듈이 많아질수록 관리가 힘든 점이 제일 컸으며 점점 NodeJS 코드를 다루는 상황이 많아지고 있어 모듈관리를 한가지 스타일로 유지하고 싶었다.</p>\n<p><img src=\"http://webpack.github.io/assets/what-is-webpack.png\" alt=\"웹팩설명 다이어그램\"></p>\n<p>Browserify를 문제없이 사용하던 중 Webpack 이란 도구를 알게 되었는데, Webpack은 AMD와 CommonJS를 동시에 지원할 뿐 아니라 기본적으로 부분을 캐싱하여 변경점만 번들링하는 방식이라 속도가 빠르고 Karma와 같은 테스트 런너와의 연동도 훨씬 좋았다. 무엇보다 제일 활발하게 진행되는 오픈소스 프로젝트였기에 발전 가능성이 제일 커 보였다. 결과적으로 앞으로 새로 시작하는 프로젝트는 물론 이미 Browserify로 작업된 프로젝트들도 단계적으로 Webpack을 사용할 예정이다</p>\n<h3>설치 및 간단한 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install webpack -g</code></pre></div>\n<p>보통의 nodejs 모듈처럼 npm을 이용해 webpack을 설치한다.\nglobal에 설치하는 것을 예제로 사용했지만 프로젝트별로 따로 설치하는 것을 추천한다.</p>\n<p>index.js라는 엔트리 포인트를 시작으로 내부의 디펜던시가 해결되어 머징된 bundle.js라는 파일을 만들어내는 예제다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack ./src/index.js ./dist/bundle.js</code></pre></div>\n<p>html파일에서 실제로 로드하는 자바스크립트 파일은 bundle.js가 되는것이다.</p>\n<h3>설정파일</h3>\n<p>Webpack을 실행할 때 대부분의 설정은 커맨드 라인에서 직접 파라메터로 설정이 가능하지만 매번 해줄 수 없으니 프로젝트의 설정을 파일로 만들어 간편하게 실행한다.\n<strong>webpack.config.js</strong>란 파일을 만들고 위의 커맨드 라인 예제와 동일한 파라메터를 설정파일로 만들어 보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token operator\">:</span> <span class=\"token string\">\"./src/index.js\"</span><span class=\"token punctuation\">,</span>\n    output<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      filename<span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/bundle.js\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 설정파일을 만들어두면 해당위치에서</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack</code></pre></div>\n<p>파라메터 없이 실행해도 파일에 저장된 설정대로 bundle.js파일을 만들어준다.</p>\n<h3>watch 모드</h3>\n<p>watch 모드는 프로젝트의 js 소스코드가 변경될 때마다 자동으로 다시 bundle.js 파일을 만들어주는 기능을 한다. 개발중에는 주로 watch 모드를 이용하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack -w</code></pre></div>\n<p>Webpack을 <code class=\"language-text\">-w</code> 파라메터를 주고 실행하거나 설정파일에 <code class=\"language-text\">watch:true</code>를 추가한다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/13038853/c523112e-d3db-11e5-8cdf-164866b79bc9.jpeg\" alt=\"0eba1c1616fa0ed9e77075c5ce795ac7\"></p>\n<p>첫 번째 실행 시점에서 Webpack이 종료되지 않고 대기하다가 코드를 수정하면(여기서는 sub.js) <strong>해당 파일만</strong> 다시 bundle.js에 적용된다.\n여기서 중요한 점은 특정 파일의 일부분을 수정해서 저장했는데 전체의 코드를 다시 훑어서 전체의 bundle.js를 다시 만드는것이 캐싱된 상태에서 변경이 일어난 자바스크립트 파일만 변경해 주는 방식이라는 것이다. 그래서 매우 빠르다. Browserify는 이렇게 하려면 추가적인 모듈과 복잡한 설정이 필요했다.그리고 보여주는 터미널 로그도 Browserify보다 이쁘고 필요한 정보를 잘 제공해 준다.</p>\n<h3>로더</h3>\n<p>Webpack은 로더라는 일종의 플러그인들을 이용해 기능을 확장할 수 있다.\nES6와 ES7문법으로 작업하고 바벨 로더를 이용해 번들링 하는 과정에서 결과물을 ES5로 Transpile 할 수 있으며 Uglify 로더를 이용해 코드를 난독화도 할수 있다. 빌드하는 과정을 자동화 하는 도구로 Grunt나 Gulp가 많이 사용되는데 그런 도구들이 해주던 역할을 이 로더들을 이용해서 처리할 수 있다. 필요한 로더는 직접 만들 수 있지만 이미 많은 로더들이 구현되어 있어 바로 사용할 수가 있다. (<a href=\"http://webpack.github.io/docs/list-of-loaders.html\">로더목록</a>)</p>\n<h3>장점</h3>\n<p>모듈 로드 및 디펜던시 관리도구로써의 Webpack의 장점은 아래와 같다.</p>\n<ul>\n<li>관련 도구중 제일 핫하다.</li>\n<li>AMD &#x26; CommonJS 코드 둘다 사용 가능</li>\n<li>큰 어려움없이 RequireJS나 Browserify에서 전환이 가능하다.</li>\n<li>Watch모드의 캐싱으로 개발시 변환속도가 매우 빠르다.</li>\n<li>특별한 자동화도구 없이 로더를 이용해 기능을 확장할 수 있다.</li>\n<li>Karma, Babel등 최신 자바스크립트 도구들과의 연동성이 좋다.</li>\n<li>개발용 서버를 따로 구성할 필요 없이 바로 사용 가능한 <a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">webpack-dev-server</a>가 있다.</li>\n</ul>\n<h3>Quick start!</h3>\n<p>디렉토리를 하나 만들고 설정파일을 만든다. (webpack.config.js)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//webpack.config.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token operator\">:</span> <span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">,</span>\n    output<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        filename<span class=\"token operator\">:</span> <span class=\"token string\">\"bundle.js\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>만들려는 자바스크립트 어플리케이션의 시작점이 되는 index.js파일을 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//index.js</span>\n<span class=\"token keyword\">var</span> sub <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./sub'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsub<span class=\"token punctuation\">.</span><span class=\"token function\">subInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>index.js는 sub라는 모듈이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//sub.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">subInit</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'this is sub2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>우리가 만들 어플리케이션은 페이지에 로드 되자마자 콘솔에 로그 한 줄을 남긴다.\n이제 모든 게 통합된 번들 파일을 만든다.(컴파일이라고도 할 수 있겠지만 굳이 따지만 링킹과정에 가깝겠다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ webpack</code></pre></div>\n<p>html파일을 만들어 번들파일을 불러온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>X-UA-Compatible<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>IE=edge,chrome=1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>TITLE HERE<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>“./bundle.js”</span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>이제 브라우저에서 html파일을 열어 본다.</p>\n<p>자 이제 어플리케이션에 기능을 더 추가해본다!!</p>\n<p>보다 추가적인 자세한 사용법은 <a href=\"https://webpack.github.io/\">Webpack사이트</a>에서 찾을 수 있다.</p>","fields":{"slug":"/2016-02-15-Webpack으로 자바스크립트 모듈관리 하기/"},"excerpt":"디펜던시 모듈 관리 기존의 프론트엔드 자바스크립트는 특별히 모듈화나 디펜던시관리에 대한 방법이 없어 필요한 자바스크립트 파일을 정해진 순서에 맞게 직접 스크립트 태그로 로드하고 각각 약속된 네임스페이스에 담아 공유했었다. 이런 방식은 프로젝트가 커질수록 그리고 참여 개발자가 많을수록 문제를 일으켰다. 이후 개발자들에 의해 AMD와 CommonJS 두가지 방법으로 모듈 관리 환경이 발전하게 되었는데,\nAMD 방식은 RequireJS가 많이 사용되고 있고 CommonJS는 Browserify가 인기가 많았다. 그리고 CommonJS는…","frontmatter":{"title":"Webpack으로 자바스크립트 모듈관리 하기","date":"15 February, 2016","categories":"frontend, javascript, webpack","image":null,"imageAuthor":null,"imageAuthorLink":null,"imageFromLink":null,"imageFrom":null}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2019-05-22-크롬 네이티브 레이지 로딩/"},"frontmatter":{"title":"크롬 네이티브 레이지 로딩","categories":"frontend, tool","date":"22 May, 2019"},"excerpt":"레이지 로딩이란? 좋은 기회로 2019년 구글I/O에 참석했다. 웹 기술 세션 중에는 크게 눈에 띄는 세션은 없었지만, 일부 세션에서 소개된 웹과 관련 기술 몇 가지는 흥미로웠다. Native Lazy Loading, Portals, Duplex, Rich Results 정도가 나의 관심을 끌었다. 그중 키노트에서 시작해 몇 개의 세션에서 두루두루 언급한 네이티브 레이지 로딩이 제일 기대됐다. 관련 세션 레이지 로딩, 특히 이미지 레이지 로딩은 새로운 기술은 아니다. 기존 브라우저는 웹페이지를 불러올 때 초기부터 전체 영역에 해당…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2021-05-17/"},"frontmatter":{"title":"개발을 잘 하는 습관","categories":"developer, habbit","date":"17 May, 2021"},"excerpt":"저는 반복적으로 하는 작업이 있다면 가장 나에게 맞는 최적화된 루틴을 만들고 그 작업을 할 때마다 생각 없이 그대로 하는 편이에요. 정해진 루틴은 고집스럽게 유지하진 않고요. 경험에 따라 혹은 관련 지식이 늘어남에 따라 루틴을 조금씩 개선합니다. 루틴은 “현재 내가 이 일을 잘 하기 위해 알고 있는 위한 가장 나은 방법”이라고 할 수 있겠네요. 그리고 실행할 때는 이 생각 저 생각 할 필요 없이 그냥 실행합니다. 각 단계에 대한 생각만 하는 것이죠. 예를 들어 제가 사는 아파트는 매주 한 번 재활용 수거를 하는데 재활용을 할 때도…"},{"fields":{"slug":"/2021-04-20/"},"frontmatter":{"title":"욕 안 먹는 개발자되기","categories":"developer","date":"20 April, 2021"},"excerpt":"직장인이라면 자연스럽게 업무를 대하는 태도가 캐릭터 처럼 만들어져요. 개발자도 마찬가지고요. 신입이라고 태도가 항상 나쁜 것도 아니고 경력이라고 항상 태도가 좋은 것도 아니에요. 코딩 스킬처럼 개선될 수도 있고요. 연차가 적을수록 몰라서 잘못된 태도를 갖는 경우가 많습니다. 이렇게 만들어진 태도는 보통 연차가 높을수록 개선되기 힘들다고들 하죠. 태도라는 큰 추상적인 덩어리는 억울하게도 한 부분, 한 사건에 의해 모든 것을 퉁쳐서 판단되기도 하죠. 이런 태도의 중요한 한 부분은 업무 중 문제가 발생했을 때에 뚜렷하게 나타난다고 생각…"},{"fields":{"slug":"/2021-02-22/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 2","categories":"frontend, nodejs, tdd","date":"22 February, 2021"},"excerpt":"파트 1에서는 기본 자바스크립트 개발 환경을 러나와 함께 구축해봤어요. 기본 환경만으로 충분하신 분들도 계시겠지만 보통은 그렇지 않을 겁니다.\n이제 두 가지 개발 환경을 추가할 건데요. 타입 스크립트와 리액트 개발 환경이에요. 우선 타입스크립트 환경을부터 추가할 거예요. 그전에 러나로 해줘야 할 작업이 있습니다. 타입스크립트 환경도 결국 지금까지 저희가 구축한 자바스크립트 환경 위에 만들어질 것이기 때문에 디펜던시 모듈을 공유할 수 있도록 만들고 환경 설정 파일들도 기본 자바스크립트의 환경설정 파일들을 확장해서 사용할 거예요. 그…"},{"fields":{"slug":"/2021-02-15/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 1","categories":"frontend, nodejs, tdd","date":"15 February, 2021"},"excerpt":"개발을 하다 보면 특정 환경에서 빠르게 코드를 작성하고 그 결과를 확인해보고 싶을 때가 있어요. 라이브러리나 프레임웍 혹은 언어를 공부할 때나 아이디어를 빠르게 실험하거나 프로토타입 해보고 싶을 때 그렇지요. 바닐라 자바스크립트로 충분한 환경이라면 디렉터리 하나 만들고 js 파일 하나 html 파일 하나 만들어서 에디터를 열고 브라우저를 열어서 html 파일을 불러오는 것까지 하면 기본적인 준비가 끝나요. 근데요. 이런 바닐라 자바스크립트 환경을 만드는 것조차도 사실 귀찮을 때가 있어요. 이런 기본 환경도 귀찮은데 실무의 복잡한 …"},{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"developer, recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"}]}},"pageContext":{"slug":"/2016-02-15-Webpack으로 자바스크립트 모듈관리 하기/","categoriesRegex":"/frontend|javascript|webpack/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}