{"componentChunkName":"component---src-templates-post-tsx","path":"/2020-03-12-은닉을-향한-자바스크립트의-여정/","result":{"data":{"markdownRemark":{"html":"<p>ECMAScript 클래스 필드(class field) 명세중에 <code class=\"language-text\">Private field</code> 즉 <code class=\"language-text\">Private Property</code> (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로 Private 속성 에 대해 제대로 알아보기로 했다. 물론 이제 프로젝트에서도 적극적으로 사용할 생각이다. public 한 클래스 필드는 바벨 플러그인 <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-class-properties\">babel-plugin-proposal-class-properties</a>을 통해 이미 예전부터 아주 유용하게 사용하고 있었다.</p>\n<h2>프라이버시가 없는 설움</h2>\n<p>객체의 private 한 속성을 만들 수 없었던 자바스크립트에서는 몇 가지 대안을 사용해왔다. 다른 클래스 기반의 언어처럼 근본적으로는 private 하게 만들 수 없었기 때문에 컨벤션으로 약속하거나 비슷한 효과를 주는 꼼수를 사용했었다.</p>\n<p>컨벤션을 이용한 방법으로는 관용적으로 가장 많이 사용되는 것이 <code class=\"language-text\">_</code> 즉 언더스코어 프리픽스를 속성 명에 사용하는 것이다. 이런 방법은 파이썬에서도 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">SomeConstructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_privateProp <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>더 올드하고 구질구질해 보이기 위해 예제코드에서 class 키워드 대신 함수 생성자를 사용했다.</p>\n<p>이 방법은 컨벤션을 이용해 private로 취급할 뿐이지 실제로는 public으로 동작하기 때문에 외부에서 얼마든지 접근할 수 있었다. 하지만 <code class=\"language-text\">_</code> 가 붙은 필드나 메서드는 외부에서 사용하면 안 된다는 약속은 코드 가독성을 꽤 높이는 데 일조를 했었다고 생각한다. 마치 <code class=\"language-text\">for</code>문에 사용하는 인덱스 변수를 아무 생각 없이 <code class=\"language-text\">i</code>로 사용했었던 것과 마찬가지로, 약속대로 일관성 있게만 사용한다면 꽤 유용한 방법이었다. 더글라스 크록포드(Douglas Crockford, 이하 더글라스)는 <a href=\"https://www.crockford.com/code.html\">블로그</a>를 통해 이런 방법은 private이 아닌 필드를 마치 private로 동작하는 것으로 오인할 수 있으니 피해야 한다고 했지만 개발자 간의 약속이 확실하고 일관성만 유지된다면 괜찮은 방법이었다고 생각한다. JSDoc이 보편화된 뒤로는 문서 작성을 자동화 할 수 있는 본래의 목적 외에도 코드 내의 JSDoc 태그를 이용해서 여러 가지 정보와 편의 기능을 제공하는 에디터가 늘었다. JSDoc은 문서 자동화 도구임과 동시에 언어의 표현력을 주석으로 극복한 확장 문법이 되었다. JSDoc에서는 <code class=\"language-text\">@private</code> 태그를 사용해 해당 멤버가 private 함을 표현했다. <code class=\"language-text\">_</code> 보다는 훨씬 명시적이고 문서도 자동으로 만들어지니 얼마나 좋은가? 자바스크립트 진영에서는 점점 <code class=\"language-text\">_</code> 를 사용하지 않게 된다. 나 역시 동일한 이유로 <code class=\"language-text\">_</code> 의 사용을 컨벤션으로 금지하는 것에 찬성했다.</p>\n<p>근본적으로 접근이 불가능한 private 속성을 만드는 방법으로는 클로저를 이용한 방법이 있다. 이는 더글라스가 <code class=\"language-text\">_</code> 대신 사용하라고 제안한 방법이기도 하다. 자바스크립트가 늘 그랬듯 이상하거나 획기적인 다른 방법이 있을 수도 있겠지만 클로저를 사용하는 방법이 제일 많이 사용된다. 사실 클로저를 적절히 사용한 예이기도 하다.(<a href=\"https://blog.shiren.dev/2016-06-27-%ED%81%B4%EB%A1%9C%EC%A0%80,-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BA%A1%EC%8A%90%ED%99%94%EC%99%80-%EC%9D%80%EB%8B%89%ED%99%94/\">참조: 클로저, 그리고 캡슐화와 은닉화</a>)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">SomeConstructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> privateProp <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">doSomethingWithPrivateProp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">this</code>를 사용해 데이터에 접근하는 문법과 모양새가 달라지기 때문에 <code class=\"language-text\">this</code> 컨텍스트와 혼용할 때는 코드의 일관성을 잃어 가독성이 떨어질 수 있겠지만 효과적으로 데이터를 격리할 수 있었다. 인스턴스 컨텍스트와 차원이 분리될 정도의 격리다. 이러한 접근 방법은 데이터를 숨기는 것에도 유용하지만 메서드를 숨기는 데도 유용하다. 이런 특성을 이용해서 흔히 말하는 <a href=\"https://coryrylan.com/blog/javascript-module-pattern-basics\">모듈 패턴</a>을 구현했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">SomeModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> privateProp <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">_doSomethingWithPrivateProp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">publicMethod</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">_doSomethingWithPrivateProp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    publicProp<span class=\"token punctuation\">,</span>\n    publicMethod\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>모듈 패턴은 특정 부분(고수준 인터페이스나 ES6의 Module을 사용할 수 없는 상황)에선 아직 유용하지만 ES6 Module(이후 ESM)의 등장으로 FE 프로젝트 코드 베이스에서 사라져갔다. 내가 실제로 모듈 패턴을 사용해서 개발했던 때가 언제인지도 사실 기억이 나질 않는다. 최소 5년은 넘는다. 사실 이런 류의 모듈 패턴이 ESM 모태이기도 하고 해결하고자 하는 문제도 동일하다. 심지어 웹팩을 통해 변환된 ESM의 변환 코드를 보면 기존의 모듈 패턴과 비슷한 방법이 사용된다. private과 같은 은닉성에 대한 갈증은 사실 ESM을 통해 어느 정도 해결되기도 했지만, 생성자의 인스턴스 컨텍스트별로 private 데이터를 만들어야 할 상황에서는 크게 달라진 점이 없었다. 애초에 방향이 다르다.</p>\n<p><code class=\"language-text\">Symbol</code>을 사용하면 조금 더 ECMAScript 다운 꼼수의 prviate 속성을 만들 수 있다. 사실 꼼수라기보다는 ES6의 자원을 적절히 사용한 최적의 방법이라고 생각한다. 예전에 생각해보곤 멋진 생각이라고 지혼자 좋아했었는데 아직 실무에서 사용해보진 못했다. 그리고 뭐 이제 private을 정식으로 지원하니까..</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> privateMethodName <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> privatePropName <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>privatePropName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">[</span>privateMethodName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'private method'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">publicMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>privateMethodName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>privatePropName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>모듈 스코프 안에서는 symbol을 사용할 수 있어 해당 필드나 메서드에 접근할 수 있지만, symbol을 export 하지 않는 한 외부에서는 접근할 방법이 없다. 접근할 필드의 이름이 무엇인지 모르니까 말이다. 이 방법은 속성의 이름을 다른 차원으로 격리한 케이스다.</p>\n<h2>나이스 샵(#)</h2>\n<p>아무튼, 드디어 자바스크립트에서도 진정한 의미의, 꼼수가 아닌 언어가 제공하는 정상적인 방법으로 클래스에 private 속성을 만들 수 있게 되었다. <a href=\"https://github.com/tc39/proposal-class-fields/\">TC39의 스펙문서</a>를 토대로 간단하게 특징을 요약하면 아래와 같다.</p>\n<ul>\n<li>Stage-3 단계에 있는 스펙으로 특별한 결격 사유가 없는 한 표준 스펙이 될 것이다. 물론 변경되거나 개선될 여지는 있다.</li>\n<li><code class=\"language-text\">private</code>과 같은 키워드를 사용하지 않는다. 대신 <code class=\"language-text\">#</code> 즉 샵 프리픽스를 사용한다. <strong>키워드가 아니라 프리픽스다.</strong> 속성 명 앞에 <code class=\"language-text\">#</code>이 붙으면 Private 필드로 동작한다.</li>\n<li>Class Field Decalarations 스펙의 일부다. public과 다른 점은 클래스의 필드 선언을 통해서만 만들 수 있다. 즉 동적으로 객체에 private 필드를 추가할 수 없다.</li>\n<li>\n<p>메서드에는 제한적이다. <strong>메서드 선언으로 사용할 수 없다.</strong> private 메서드를 만들려면 함수 표현식으로 정의해야 한다.</p>\n<ul>\n<li>어디까지나 현재로서는 그렇다는 말이다. 스펙이 업데이트될 수도 있다. (<a href=\"https://docs.google.com/presentation/d/1Q9upYkWnPjJaVc8k9q3U6NekDch8tsz7CgV-Xm55-5Y/edit#slide=id.p\">Class fields and private methods: Stage 3 update</a>)</li>\n</ul>\n</li>\n<li><strong>Computed Property Name을 사용할 수 없다.</strong> <code class=\"language-text\">#foo</code> 자체만 식별자로 허용되고 <code class=\"language-text\">#[fooName]</code> 이건 문법 오류다.</li>\n<li><strong>모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.</strong> 그렇기 때문에 독특한 특징이 있다.(그 특징은 뒷부분에서 다룬다)</li>\n</ul>\n<p>아직은 보통의 클래스 기반 언어만큼의 지원은 아니다. 약간의 제약은 있지만, 아직 stage-3이고 언제든 업데이트되거나 개선될 여지가 있다. 왜 private method가 초반에 같이 논의되지 않았는지는 궁금하다.</p>\n<p>이제 사용해보자. (에러 메시지를 확인하기 위해 타입스크립트 컴파일러를 사용한다. 하지만 예제코드는 ECMAScript 문법만 사용한다)</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>간단하게 <code class=\"language-text\">#</code> 프리픽스를 이용해서 <code class=\"language-text\">Human</code> 클래스에 <code class=\"language-text\">#age</code>라는 속성을 만들어봤다.</p>\n<p>정말 private 한지 돌직구로 접근해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error TS18013: Property '#age' is not accessible outside class 'Human' because it has a private identifier.</span></code></pre></div>\n<p>당연히 클래스 외부에서 접근할 수 없는 속성이라는 에러 메시지가 출력된다.</p>\n<p>그리고 미리 말했듯 <code class=\"language-text\">#</code>은 키워드가 아니라 속성 이름의 프리픽스다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error TS2551: Property 'age' does not exist on type 'Human'. Did you mean '#age'?</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">#</code> 없이는 접근할 수 없다. 식별자의 이름의 일부를 제외하고 접근했으니 없는 속성에 접근한 것이다.</p>\n<p>이제 정상적으로 private 속성을 클래스에서 정의하고 사용해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span></code></pre></div>\n<p>외부에 <code class=\"language-text\">getAge()</code> 라는 게터(getter)를 노출해 <code class=\"language-text\">#age</code> 값에 접근할 수 있게 했다.</p>\n<p>당연한 거지만 private로 만든 속성은 해당 private 속성이 정의된 클래스를 제외하고는 어디에서도 접근이 불가능하다. 상속받은 클래스에서도 접근이 불가능하다. 자바스크립트가 이렇게 정상적일 리가 없어라면서 의심할 사람들을 위해 당연할지라도 언급해봤다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age <span class=\"token operator\">-</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Property '#age' is not accessible outside class 'Human' because it has a private identifier.</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Human</code> 을 상속받은 <code class=\"language-text\">Person</code> 에서는 <code class=\"language-text\">Human</code>의 private 속성 <code class=\"language-text\">#age</code>에 접근할 수 없다.</p>\n<p>하지만 약간 독특한 특징이 있다. private 속성의 독특함이 아니라 자바스크립트이기 때문에 유달리 독특해 보이는 특징이다. 그리고 이 특징은 상단에 정리한 특징 중 <strong>\"모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.\"</strong> 라는 내용에 의해 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 20</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 20</span></code></pre></div>\n<p>위의 예제는 private 을 전혀 사용하지 않은 코드다. <code class=\"language-text\">Human</code>을 상속한 <code class=\"language-text\">Person</code>객체에서 <code class=\"language-text\">age</code>를 중복해서 선언하고 다른 이름의 게터 <code class=\"language-text\">getFakeAge()</code>를 정의했다. public 속성이라면 <strong>this 컨텍스트에는 age 속성이 하나기 때문에 age의 값이 20이다.</strong> 이는 <code class=\"language-text\">Human</code>의 <code class=\"language-text\">getAge()</code>를 실행하던 <code class=\"language-text\">Person</code>의 <code class=\"language-text\">getFakeAge()</code>를 실행하던 동일하게 20이다. 애초에 <code class=\"language-text\">this</code>가 가리키는 <strong>인스턴스 컨텍스트에 <code class=\"language-text\">age</code>는 하나밖에 없기 때문이다.</strong></p>\n<p>자 이제 <code class=\"language-text\">age</code>를 private 속성 <code class=\"language-text\">#age</code>로 바꿔보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 20</span></code></pre></div>\n<p>동일하게 <code class=\"language-text\">this.#age</code>에 접근하는 <code class=\"language-text\">getAge()</code>와 <code class=\"language-text\">getFakeAge()</code>의 결과가 다르다. 자바스크립트를 오래 개발해 왔던 사람이라면 충격과 공포 그리고 혼돈이 느껴질 것이다. 이게 뭐지?</p>\n<p><code class=\"language-text\">#age</code> 즉 private 속성은 그동안 우리가 알고 있던 this 의 그 컨텍스트와는 다른 방식으로 저장된다. <strong>기존처럼 인스턴스별로 독립적인 공간을 갖지만, 추가로 클래스 별로 독립적인 공간을 갖는 것이다.</strong> 쉽게 말하면 <code class=\"language-text\">Human</code> 클래스 스코프의 <code class=\"language-text\">#age</code>와 <code class=\"language-text\">Person</code> 클래스 스코프의 <code class=\"language-text\">#age</code>는 다르다는 것이다. 그러므로 <code class=\"language-text\">Human</code> 클래스에 속한 <code class=\"language-text\">getAge()</code>가 실행될때는 <code class=\"language-text\">Human</code>의 <code class=\"language-text\">#age</code>에 접근하고 <code class=\"language-text\">Person</code>의 <code class=\"language-text\">getFakeAge()</code>가 실행될 때는 <code class=\"language-text\">Person</code>의 <code class=\"language-text\">#age</code>에 접근하는 것이다. 바로 그게 \"모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.\"라는 문장의 의미이다.</p>\n<p>전반적으로 Private 필드 라는 개념에서 크게 벗어나지 않지만, <strong>마지막에 다룬 내용은 제대로 이해하지 않고 사용하면 특정 상황에서 발견하기 힘든 오류를 만들 수 있을 것 같다. 조심하자.</strong></p>\n<h2>끝으로</h2>\n<p>처음 TC39에서 스펙을 발견하고도 한동안 1도 관심을 두지 않을 정도로 private이라는 개념에 대해서 무심했다. private 이랄것이 없는 객체를 다루는 환경에서 오랫동안 개발을 해서 그런지 모르겠지만 사실 큰 필요성을 느끼지 못하고 있었다. 그런 개념이 없었기에 오히려 좀 더 의미적으로 식별자를 분리해 조심히 다루고 클로저를 적절히 활용하는 게 몸에 뱄다. 그게 어찌 보면 더 (자바스크립트 적으로) 명확한 면도 있었다. 앞으로 자바스크립트 진영에 private이란 개념이 클래스나 어플리케이션 설계에 어떤 영향을 주게 될지 기대된다. 아마도 자바스크립트 개발자들은 private 속성을 이용해 또 다른 꼼수에 악용(?) 가능성이 크다. 꼼수에 새로운 가능성을 열어줬다고나 할까? <strong>아무튼 난 이래서 자바스크립트가 좋다. 라고 마무리를 지으며 와인 한잔과 함께 외롭게 석양을 바라보며 씁쓸한 미소를 짓는다.</strong></p>","fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…","frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","date":"12 March, 2020","categories":"javascript, ecmascript, private"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2018-02-23-ECMAScript 스펙 톺아보기: Primitive/"},"frontmatter":{"title":"ECMAScript 스펙 톺아보기: Primitive","categories":"javascript","date":"23 February, 2018"},"excerpt":"ECMAScript 스펙 톺아보기: Primitive 프리미티브에 대한 의문 현재 팀 내부에서는 시니어들이 팀 인력 채용 프로세스를 개선하고 있다. 프로세스 중에서도 현재는 필기시험 문제를 재출제하는 중인데 이게 생각보다 쉽지 않아 매일 매일 서로 의견이 분분하다. 그러던 어느 날 프리미티브에 대한 의견을 나누던 중 자바스크립트의 프리미티브를 객체 같이 사용된다고 설명해도 되느냐 안되느냐의 문제를 놓고 토론을 하게 되었는데 내 의견은 표면적으로 객체처럼 사용할 수 있기에 객체 같이 취급된다고 표현해도 된다는 의견이었고 다른 한 멤…"},{"fields":{"slug":"/2017-09-18-웹 기술로 구현하는 Adaptive HTTP Streaming/"},"frontmatter":{"title":"웹 기술로 구현하는 Adaptive HTTP Streaming","categories":"frontend, javascript","date":"18 September, 2017"},"excerpt":"웹 기술로 구현하는 Adaptive HTTP Streaming 한국은 물론 세계적으로 엄청난 양의 동영상 콘텐츠가 소비되고 있다. 플래시가 대세였던 웹 동영상 기술이 점차 표준 기술인 HTML5 비디오로 전환되었고 요즘은 대부분의 동영상 서비스는 HTML5를 기반으로 서비스되고 있다. 동영상 기술은 점차 고도화되어 네트워크 환경에 따른 최적의 동영상 품질을 스트리밍해 버퍼링없는 서비스를 제공하기 위해 여러 방법들이 모색되었고 그중 하나가 새로 프로토콜을 만드는 대신 기존의 HTTP를 이용해 구현하는 Adaptive HTTP Str…"},{"fields":{"slug":"/2017-02-21-쉽게 이해하는 자바스크립트 프로토타입 체인/"},"frontmatter":{"title":"쉽게 이해하는 자바스크립트 프로토타입 체인","categories":"javascript","date":"21 February, 2017"},"excerpt":"l 자바스크립트는 객체 지향 언어이자 함수를 1급 객체로 취급하기 때문에 함수형 프로그래밍도 가능한 멀티 패러다임 언어이다. 자바스크립트를 조금이라도 다뤄봤던 사람이라면 익히 알고 있겠지만 자바스크립트에는 클래스란 개념이 없어 객체 생성이나 상속이 다른 언어와 다르고 특히 OOP는 주로 프로토타입이란 메커니즘을 통해 이루어진다. 검색을 조금만 해보면 프로토타입을 다룬 아티클들은 많이 찾아볼 수 있다. 하지만 여기서는 프로토타입에서도 상속을 구현하는 핵심 메커니즘인 포로토타입 체인에 대해 집중적으로 다룬다. 객체 자바스크립트에서 객…"},{"fields":{"slug":"/2017-01-03-RxJS와 함께하는 함수형 리액티브 프로그래밍/"},"frontmatter":{"title":"RxJS와 함께하는 함수형 리액티브 프로그래밍","categories":"javascript, reative, rxjs, translation","date":"03 January, 2017"},"excerpt":"원글: https://www.sitepoint.com/functional-reactive-programming-rxjs/ RxJS와 함께하는 함수형 반응형 프로그래밍 이 글은 Moritz Kröger, Bruno Mota와 Vildan Softic의 검수를 받았다. SitePoint의 컨텐트들이 최고가 될 수 있게 도와주는 SitePont의 모든 동료 리뷰어들에게 감사를 표한다. 본론으로 들어가기 전에 한가지 중요한 질문을 던져 본다. \"반응형 프로그래밍이란 무엇인가?\" 지금 시점에서 가장 일반적인 답변은 \"반응형 프로그래밍은 동…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2020-06-15-유용한테스트케이스를위한개발자의자세/"},"frontmatter":{"title":"유용한 테스트 케이스를 위한 개발자의 자세","categories":"test, tdd, unittest","date":"15 June, 2020"},"excerpt":"각종 커뮤니티에 주기적으로 등장하는 \"private 메서드를 테스트하려면 어떻게 하나요?\" 혹은 \"private 메서드를 테스트해야 하나요?\" 와 같은 질문을 보면서 언젠가는 관련해서 정리해봐야겠다고 생각했었는데 꽤 시간이 흘러 이 내용으로 글을 써본다. 주제 자체는 간단한 편이지만 사람마다 생각이 다른 것 같다. 특히 해외 개발자들의 의견이 분분한 것 같다. 사실 이 문제는 효과적인 테스트 케이스(이하 TC)란 무엇인가란 질문과 비슷하다. private 메서드는 객체지향적인 관점에서 생각한 것이고 노출된 함수 내부에서 접근하는,…"},{"fields":{"slug":"/2020-03-24-개발자와명상/"},"frontmatter":{"title":"개발자와 명상","categories":"life, meditation, productivity","date":"24 March, 2020"},"excerpt":"언젠가부터 여러 가지 걱정들로 머릿속이 복잡해지고 있었다. 이런 상황에서는 운동과 독서가 해결책이 될 수 있는데 운동은 평소 꾸준히 하는 편이었고 독서량을 많이 늘려봤다. 기술 서적이 아닌 내 삶에 필요하다고 생각하는 주제의 책들을 읽었다. 하지만 뭔가 부족했다. “생각을 정리할 시간이 필요하다.”라고 생각했지만, 막상 생각을 정리할 시간을 내기 힘들었다. 지금 생각해보면 그게 힘들었던 건지 생각을 직접적으로 대면하기 두려웠었는지 모르겠다.  몸뚱아리는 현재에 있었지만, 정신과 생각은 미래와 과거를 수없이 오갔다.  마음이 평화롭…"},{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript, ecmascript, private","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"}]}},"pageContext":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/","categoriesRegex":"/javascript|ecmascript|private/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}