{"componentChunkName":"component---src-templates-post-tsx","path":"/2020-03-12-은닉을-향한-자바스크립트의-여정/","result":{"data":{"markdownRemark":{"html":"<p>ECMAScript 클래스 필드(class field) 명세중에 <code class=\"language-text\">Private field</code> 즉 <code class=\"language-text\">Private Property</code> (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로 Private 속성 에 대해 제대로 알아보기로 했다. 물론 이제 프로젝트에서도 적극적으로 사용할 생각이다. public 한 클래스 필드는 바벨 플러그인 <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-class-properties\">babel-plugin-proposal-class-properties</a>을 통해 이미 예전부터 아주 유용하게 사용하고 있었다.</p>\n<h2>프라이버시가 없는 설움</h2>\n<p>객체의 private 한 속성을 만들 수 없었던 자바스크립트에서는 몇 가지 대안을 사용해왔다. 다른 클래스 기반의 언어처럼 근본적으로는 private 하게 만들 수 없었기 때문에 컨벤션으로 약속하거나 비슷한 효과를 주는 꼼수를 사용했었다.</p>\n<p>컨벤션을 이용한 방법으로는 관용적으로 가장 많이 사용되는 것이 <code class=\"language-text\">_</code> 즉 언더스코어 프리픽스를 속성 명에 사용하는 것이다. 이런 방법은 파이썬에서도 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">SomeConstructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_privateProp <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>더 올드하고 구질구질해 보이기 위해 예제코드에서 class 키워드 대신 함수 생성자를 사용했다.</p>\n<p>이 방법은 컨벤션을 이용해 private로 취급할 뿐이지 실제로는 public으로 동작하기 때문에 외부에서 얼마든지 접근할 수 있었다. 하지만 <code class=\"language-text\">_</code> 가 붙은 필드나 메서드는 외부에서 사용하면 안 된다는 약속은 코드 가독성을 꽤 높이는 데 일조를 했었다고 생각한다. 마치 <code class=\"language-text\">for</code>문에 사용하는 인덱스 변수를 아무 생각 없이 <code class=\"language-text\">i</code>로 사용했었던 것과 마찬가지로, 약속대로 일관성 있게만 사용한다면 꽤 유용한 방법이었다. 더글라스 크록포드(Douglas Crockford, 이하 더글라스)는 <a href=\"https://www.crockford.com/code.html\">블로그</a>를 통해 이런 방법은 private이 아닌 필드를 마치 private로 동작하는 것으로 오인할 수 있으니 피해야 한다고 했지만 개발자 간의 약속이 확실하고 일관성만 유지된다면 괜찮은 방법이었다고 생각한다. JSDoc이 보편화된 뒤로는 문서 작성을 자동화 할 수 있는 본래의 목적 외에도 코드 내의 JSDoc 태그를 이용해서 여러 가지 정보와 편의 기능을 제공하는 에디터가 늘었다. JSDoc은 문서 자동화 도구임과 동시에 언어의 표현력을 주석으로 극복한 확장 문법이 되었다. JSDoc에서는 <code class=\"language-text\">@private</code> 태그를 사용해 해당 멤버가 private 함을 표현했다. <code class=\"language-text\">_</code> 보다는 훨씬 명시적이고 문서도 자동으로 만들어지니 얼마나 좋은가? 자바스크립트 진영에서는 점점 <code class=\"language-text\">_</code> 를 사용하지 않게 된다. 나 역시 동일한 이유로 <code class=\"language-text\">_</code> 의 사용을 컨벤션으로 금지하는 것에 찬성했다.</p>\n<p>근본적으로 접근이 불가능한 private 속성을 만드는 방법으로는 클로저를 이용한 방법이 있다. 이는 더글라스가 <code class=\"language-text\">_</code> 대신 사용하라고 제안한 방법이기도 하다. 자바스크립트가 늘 그랬듯 이상하거나 획기적인 다른 방법이 있을 수도 있겠지만 클로저를 사용하는 방법이 제일 많이 사용된다. 사실 클로저를 적절히 사용한 예이기도 하다.(<a href=\"https://blog.shiren.dev/2016-06-27-%ED%81%B4%EB%A1%9C%EC%A0%80,-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BA%A1%EC%8A%90%ED%99%94%EC%99%80-%EC%9D%80%EB%8B%89%ED%99%94/\">참조: 클로저, 그리고 캡슐화와 은닉화</a>)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">SomeConstructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> privateProp <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">doSomethingWithPrivateProp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">this</code>를 사용해 데이터에 접근하는 문법과 모양새가 달라지기 때문에 <code class=\"language-text\">this</code> 컨텍스트와 혼용할 때는 코드의 일관성을 잃어 가독성이 떨어질 수 있겠지만 효과적으로 데이터를 격리할 수 있었다. 인스턴스 컨텍스트와 차원이 분리될 정도의 격리다. 이러한 접근 방법은 데이터를 숨기는 것에도 유용하지만 메서드를 숨기는 데도 유용하다. 이런 특성을 이용해서 흔히 말하는 <a href=\"https://coryrylan.com/blog/javascript-module-pattern-basics\">모듈 패턴</a>을 구현했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">SomeModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> privateProp <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">_doSomethingWithPrivateProp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">publicMethod</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">_doSomethingWithPrivateProp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    publicProp<span class=\"token punctuation\">,</span>\n    publicMethod\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>모듈 패턴은 특정 부분(고수준 인터페이스나 ES6의 Module을 사용할 수 없는 상황)에선 아직 유용하지만 ES6 Module(이후 ESM)의 등장으로 FE 프로젝트 코드 베이스에서 사라져갔다. 내가 실제로 모듈 패턴을 사용해서 개발했던 때가 언제인지도 사실 기억이 나질 않는다. 최소 5년은 넘는다. 사실 이런 류의 모듈 패턴이 ESM 모태이기도 하고 해결하고자 하는 문제도 동일하다. 심지어 웹팩을 통해 변환된 ESM의 변환 코드를 보면 기존의 모듈 패턴과 비슷한 방법이 사용된다. private과 같은 은닉성에 대한 갈증은 사실 ESM을 통해 어느 정도 해결되기도 했지만, 생성자의 인스턴스 컨텍스트별로 private 데이터를 만들어야 할 상황에서는 크게 달라진 점이 없었다. 애초에 방향이 다르다.</p>\n<p><code class=\"language-text\">Symbol</code>을 사용하면 조금 더 ECMAScript 다운 꼼수의 prviate 속성을 만들 수 있다. 사실 꼼수라기보다는 ES6의 자원을 적절히 사용한 최적의 방법이라고 생각한다. 예전에 생각해보곤 멋진 생각이라고 지혼자 좋아했었는데 아직 실무에서 사용해보진 못했다. 그리고 뭐 이제 private을 정식으로 지원하니까..</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> privateMethodName <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> privatePropName <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>privatePropName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'dont touch this'</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  publicProp <span class=\"token operator\">=</span> <span class=\"token string\">'you can touch this'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">[</span>privateMethodName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'private method'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">publicMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>privateMethodName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>privatePropName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>모듈 스코프 안에서는 symbol을 사용할 수 있어 해당 필드나 메서드에 접근할 수 있지만, symbol을 export 하지 않는 한 외부에서는 접근할 방법이 없다. 접근할 필드의 이름이 무엇인지 모르니까 말이다. 이 방법은 속성의 이름을 다른 차원으로 격리한 케이스다.</p>\n<h2>나이스 샵(#)</h2>\n<p>아무튼, 드디어 자바스크립트에서도 진정한 의미의, 꼼수가 아닌 언어가 제공하는 정상적인 방법으로 클래스에 private 속성을 만들 수 있게 되었다. <a href=\"https://github.com/tc39/proposal-class-fields/\">TC39의 스펙문서</a>를 토대로 간단하게 특징을 요약하면 아래와 같다.</p>\n<ul>\n<li>Stage-3 단계에 있는 스펙으로 특별한 결격 사유가 없는 한 표준 스펙이 될 것이다. 물론 변경되거나 개선될 여지는 있다.</li>\n<li><code class=\"language-text\">private</code>과 같은 키워드를 사용하지 않는다. 대신 <code class=\"language-text\">#</code> 즉 샵 프리픽스를 사용한다. <strong>키워드가 아니라 프리픽스다.</strong> 속성 명 앞에 <code class=\"language-text\">#</code>이 붙으면 Private 필드로 동작한다.</li>\n<li>Class Field Decalarations 스펙의 일부다. public과 다른 점은 클래스의 필드 선언을 통해서만 만들 수 있다. 즉 동적으로 객체에 private 필드를 추가할 수 없다.</li>\n<li>\n<p>메서드에는 제한적이다. <strong>메서드 선언으로 사용할 수 없다.</strong> private 메서드를 만들려면 함수 표현식으로 정의해야 한다.</p>\n<ul>\n<li>어디까지나 현재로서는 그렇다는 말이다. 스펙이 업데이트될 수도 있다. (<a href=\"https://docs.google.com/presentation/d/1Q9upYkWnPjJaVc8k9q3U6NekDch8tsz7CgV-Xm55-5Y/edit#slide=id.p\">Class fields and private methods: Stage 3 update</a>)</li>\n</ul>\n</li>\n<li><strong>Computed Property Name을 사용할 수 없다.</strong> <code class=\"language-text\">#foo</code> 자체만 식별자로 허용되고 <code class=\"language-text\">#[fooName]</code> 이건 문법 오류다.</li>\n<li><strong>모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.</strong> 그렇기 때문에 독특한 특징이 있다.(그 특징은 뒷부분에서 다룬다)</li>\n</ul>\n<p>아직은 보통의 클래스 기반 언어만큼의 지원은 아니다. 약간의 제약은 있지만, 아직 stage-3이고 언제든 업데이트되거나 개선될 여지가 있다. 왜 private method가 초반에 같이 논의되지 않았는지는 궁금하다.</p>\n<p>이제 사용해보자. (에러 메시지를 확인하기 위해 타입스크립트 컴파일러를 사용한다. 하지만 예제코드는 ECMAScript 문법만 사용한다)</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>간단하게 <code class=\"language-text\">#</code> 프리픽스를 이용해서 <code class=\"language-text\">Human</code> 클래스에 <code class=\"language-text\">#age</code>라는 속성을 만들어봤다.</p>\n<p>정말 private 한지 돌직구로 접근해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error TS18013: Property '#age' is not accessible outside class 'Human' because it has a private identifier.</span></code></pre></div>\n<p>당연히 클래스 외부에서 접근할 수 없는 속성이라는 에러 메시지가 출력된다.</p>\n<p>그리고 미리 말했듯 <code class=\"language-text\">#</code>은 키워드가 아니라 속성 이름의 프리픽스다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error TS2551: Property 'age' does not exist on type 'Human'. Did you mean '#age'?</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">#</code> 없이는 접근할 수 없다. 식별자의 이름의 일부를 제외하고 접근했으니 없는 속성에 접근한 것이다.</p>\n<p>이제 정상적으로 private 속성을 클래스에서 정의하고 사용해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span></code></pre></div>\n<p>외부에 <code class=\"language-text\">getAge()</code> 라는 게터(getter)를 노출해 <code class=\"language-text\">#age</code> 값에 접근할 수 있게 했다.</p>\n<p>당연한 거지만 private로 만든 속성은 해당 private 속성이 정의된 클래스를 제외하고는 어디에서도 접근이 불가능하다. 상속받은 클래스에서도 접근이 불가능하다. 자바스크립트가 이렇게 정상적일 리가 없어라면서 의심할 사람들을 위해 당연할지라도 언급해봤다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age <span class=\"token operator\">-</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Property '#age' is not accessible outside class 'Human' because it has a private identifier.</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Human</code> 을 상속받은 <code class=\"language-text\">Person</code> 에서는 <code class=\"language-text\">Human</code>의 private 속성 <code class=\"language-text\">#age</code>에 접근할 수 없다.</p>\n<p>하지만 약간 독특한 특징이 있다. private 속성의 독특함이 아니라 자바스크립트이기 때문에 유달리 독특해 보이는 특징이다. 그리고 이 특징은 상단에 정리한 특징 중 <strong>\"모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.\"</strong> 라는 내용에 의해 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 20</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 20</span></code></pre></div>\n<p>위의 예제는 private 을 전혀 사용하지 않은 코드다. <code class=\"language-text\">Human</code>을 상속한 <code class=\"language-text\">Person</code>객체에서 <code class=\"language-text\">age</code>를 중복해서 선언하고 다른 이름의 게터 <code class=\"language-text\">getFakeAge()</code>를 정의했다. public 속성이라면 <strong>this 컨텍스트에는 age 속성이 하나기 때문에 age의 값이 20이다.</strong> 이는 <code class=\"language-text\">Human</code>의 <code class=\"language-text\">getAge()</code>를 실행하던 <code class=\"language-text\">Person</code>의 <code class=\"language-text\">getFakeAge()</code>를 실행하던 동일하게 20이다. 애초에 <code class=\"language-text\">this</code>가 가리키는 <strong>인스턴스 컨텍스트에 <code class=\"language-text\">age</code>는 하나밖에 없기 때문이다.</strong></p>\n<p>자 이제 <code class=\"language-text\">age</code>를 private 속성 <code class=\"language-text\">#age</code>로 바꿔보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  #age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>#age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getFakeAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 20</span></code></pre></div>\n<p>동일하게 <code class=\"language-text\">this.#age</code>에 접근하는 <code class=\"language-text\">getAge()</code>와 <code class=\"language-text\">getFakeAge()</code>의 결과가 다르다. 자바스크립트를 오래 개발해 왔던 사람이라면 충격과 공포 그리고 혼돈이 느껴질 것이다. 이게 뭐지?</p>\n<p><code class=\"language-text\">#age</code> 즉 private 속성은 그동안 우리가 알고 있던 this 의 그 컨텍스트와는 다른 방식으로 저장된다. <strong>기존처럼 인스턴스별로 독립적인 공간을 갖지만, 추가로 클래스 별로 독립적인 공간을 갖는 것이다.</strong> 쉽게 말하면 <code class=\"language-text\">Human</code> 클래스 스코프의 <code class=\"language-text\">#age</code>와 <code class=\"language-text\">Person</code> 클래스 스코프의 <code class=\"language-text\">#age</code>는 다르다는 것이다. 그러므로 <code class=\"language-text\">Human</code> 클래스에 속한 <code class=\"language-text\">getAge()</code>가 실행될때는 <code class=\"language-text\">Human</code>의 <code class=\"language-text\">#age</code>에 접근하고 <code class=\"language-text\">Person</code>의 <code class=\"language-text\">getFakeAge()</code>가 실행될 때는 <code class=\"language-text\">Person</code>의 <code class=\"language-text\">#age</code>에 접근하는 것이다. 바로 그게 \"모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.\"라는 문장의 의미이다.</p>\n<p>전반적으로 Private 필드 라는 개념에서 크게 벗어나지 않지만, <strong>마지막에 다룬 내용은 제대로 이해하지 않고 사용하면 특정 상황에서 발견하기 힘든 오류를 만들 수 있을 것 같다. 조심하자.</strong></p>\n<h2>끝으로</h2>\n<p>처음 TC39에서 스펙을 발견하고도 한동안 1도 관심을 두지 않을 정도로 private이라는 개념에 대해서 무심했다. private 이랄것이 없는 객체를 다루는 환경에서 오랫동안 개발을 해서 그런지 모르겠지만 사실 큰 필요성을 느끼지 못하고 있었다. 그런 개념이 없었기에 오히려 좀 더 의미적으로 식별자를 분리해 조심히 다루고 클로저를 적절히 활용하는 게 몸에 뱄다. 그게 어찌 보면 더 (자바스크립트 적으로) 명확한 면도 있었다. 앞으로 자바스크립트 진영에 private이란 개념이 클래스나 어플리케이션 설계에 어떤 영향을 주게 될지 기대된다. 아마도 자바스크립트 개발자들은 private 속성을 이용해 또 다른 꼼수에 악용(?) 가능성이 크다. 꼼수에 새로운 가능성을 열어줬다고나 할까? <strong>아무튼 난 이래서 자바스크립트가 좋다. 라고 마무리를 지으며 와인 한잔과 함께 외롭게 석양을 바라보며 씁쓸한 미소를 짓는다.</strong></p>","fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…","frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","date":"12 March, 2020","categories":"javascript"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-02-23-ECMAScript 스펙 톺아보기: Primitive/"},"frontmatter":{"title":"ECMAScript 스펙 톺아보기: Primitive","categories":"javascript","date":"23 February, 2018"},"excerpt":"ECMAScript 스펙 톺아보기: Primitive 프리미티브에 대한 의문 현재 팀 내부에서는 시니어들이 팀 인력 채용 프로세스를 개선하고 있다. 프로세스 중에서도 현재는 필기시험 문제를 재출제하는 중인데 이게 생각보다 쉽지 않아 매일 매일 서로 의견이 분분하다. 그러던 어느 날 프리미티브에 대한 의견을 나누던 중 자바스크립트의 프리미티브를 객체 같이 사용된다고 설명해도 되느냐 안되느냐의 문제를 놓고 토론을 하게 되었는데 내 의견은 표면적으로 객체처럼 사용할 수 있기에 객체 같이 취급된다고 표현해도 된다는 의견이었고 다른 한 멤…"},{"fields":{"slug":"/2017-02-21-쉽게 이해하는 자바스크립트 프로토타입 체인/"},"frontmatter":{"title":"쉽게 이해하는 자바스크립트 프로토타입 체인","categories":"javascript","date":"21 February, 2017"},"excerpt":"l 자바스크립트는 객체 지향 언어이자 함수를 1급 객체로 취급하기 때문에 함수형 프로그래밍도 가능한 멀티 패러다임 언어이다. 자바스크립트를 조금이라도 다뤄봤던 사람이라면 익히 알고 있겠지만 자바스크립트에는 클래스란 개념이 없어 객체 생성이나 상속이 다른 언어와 다르고 특히 OOP는 주로 프로토타입이란 메커니즘을 통해 이루어진다. 검색을 조금만 해보면 프로토타입을 다룬 아티클들은 많이 찾아볼 수 있다. 하지만 여기서는 프로토타입에서도 상속을 구현하는 핵심 메커니즘인 포로토타입 체인에 대해 집중적으로 다룬다. 객체 자바스크립트에서 객…"},{"fields":{"slug":"/2017-01-03-RxJS와 함께하는 함수형 리액티브 프로그래밍/"},"frontmatter":{"title":"RxJS와 함께하는 함수형 리액티브 프로그래밍","categories":"designpattern, javascript, translation","date":"03 January, 2017"},"excerpt":"원글: https://www.sitepoint.com/functional-reactive-programming-rxjs/ RxJS와 함께하는 함수형 반응형 프로그래밍 이 글은 Moritz Kröger, Bruno Mota와 Vildan Softic의 검수를 받았다. SitePoint의 컨텐트들이 최고가 될 수 있게 도와주는 SitePont의 모든 동료 리뷰어들에게 감사를 표한다. 본론으로 들어가기 전에 한가지 중요한 질문을 던져 본다. \"반응형 프로그래밍이란 무엇인가?\" 지금 시점에서 가장 일반적인 답변은 \"반응형 프로그래밍은 동…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2021-04-20/"},"frontmatter":{"title":"욕 안 먹는 개발자되기","categories":"developer","date":"20 April, 2021"},"excerpt":"직장인이라면 자연스럽게 업\u0018무를 대하는 태도가 캐릭터 처럼 만들어져요. 개발자도 마찬가지고요. 신입이라고 태도가 항상 나쁜 것도 아니고 경력이라고 항상 태도가 좋은 것도 아니에요. 코딩 스킬처럼 개선될 수도 있고요. 연차가 적을수록 몰라서 잘못된 태도를 갖는 경우가 많습니다. 이렇게 만들어진 태도는 보통 연차가 높을수록 개선되기 힘들다고들 하죠. 태도라는 큰 추상적인 덩어리는 억울하게도 한 부분, 한 사건에 의해 모든 것을 퉁쳐서 판단되기도 하죠. 이런 태도의 중요한 한 부분은 업무 중 문제가 발생했을 때에 뚜렷하게 나타난다고 생…"},{"fields":{"slug":"/2021-02-22/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 2","categories":"frontend, nodejs, tdd","date":"22 February, 2021"},"excerpt":"파트 1에서는 기본 자바스크립트 개발 환경을 러나와 함께 구축해봤어요. 기본 환경만으로 충분하신 분들도 계시겠지만 보통은 그렇지 않을 겁니다.\n이제 두 가지 개발 환경을 추가할 건데요. 타입 스크립트와 리액트 개발 환경이에요. 우선 타입스크립트 환경을부터 추가할 거예요. 그전에 러나로 해줘야 할 작업이 있습니다. 타입스크립트 환경도 결국 지금까지 저희가 구축한 자바스크립트 환경 위에 만들어질 것이기 때문에 디펜던시 모듈을 공유할 수 있도록 만들고 환경 설정 파일들도 기본 자바스크립트의 환경설정 파일들을 확장해서 사용할 거예요. 그…"},{"fields":{"slug":"/2021-02-15/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 1","categories":"frontend, nodejs, tdd","date":"15 February, 2021"},"excerpt":"개발을 하다 보면 특정 환경에서 빠르게 코드를 작성하고 그 결과를 확인해보고 싶을 때가 있어요. 라이브러리나 프레임웍 혹은 언어를 공부할 때나 아이디어를 빠르게 실험하거나 프로토타입 해보고 싶을 때 그렇지요. 바닐라 자바스크립트로 충분한 환경이라면 디렉터리 하나 만들고 js 파일 하나 html 파일 하나 만들어서 에디터를 열고 브라우저를 열어서 html 파일을 불러오는 것까지 하면 기본적인 준비가 끝나요. 근데요. 이런 바닐라 자바스크립트 환경을 만드는 것조차도 사실 귀찮을 때가 있어요. 이런 기본 환경도 귀찮은데 실무의 복잡한 …"},{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"}]}},"pageContext":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/","categoriesRegex":"/javascript/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}