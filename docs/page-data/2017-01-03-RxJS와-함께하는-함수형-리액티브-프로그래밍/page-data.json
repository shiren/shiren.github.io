{"componentChunkName":"component---src-templates-post-tsx","path":"/2017-01-03-RxJS와-함께하는-함수형-리액티브-프로그래밍/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>원글: <a href=\"https://www.sitepoint.com/functional-reactive-programming-rxjs/\">https://www.sitepoint.com/functional-reactive-programming-rxjs/</a></p>\n</blockquote>\n<h1>RxJS와 함께하는 함수형 반응형 프로그래밍</h1>\n<p>이 글은 Moritz Kröger, Bruno Mota와 Vildan Softic의 검수를 받았다. SitePoint의 컨텐트들이 최고가 될 수 있게 도와주는 SitePont의 모든 동료 리뷰어들에게 감사를 표한다.</p>\n<p>본론으로 들어가기 전에 한가지 중요한 질문을 던져 본다. \"반응형 프로그래밍이란 무엇인가?\" 지금 시점에서 가장 일반적인 답변은 \"반응형 프로그래밍은 동시성 데이터 스트림을 이용한 프로그래밍\"이 될 것이다. 그리고 적잖이 동시성이라는 단어가 비동기로 대체된 경우도 있을 것이다. 하지만 아마 이 글을 읽다 보면 스트림이 비동기일 필요가 없다는 것을 알게 될것이다.</p>\n<p>\"모든것이 스트림이다\"라는 접근 방식은 우리가 직면한 프로그래밍 문제에 직접적으로 적용될 수 있음을 쉽게 알 수 있다. 결국 CPU라는 것도 단지 명령과 데이터로 구성된 스트림을 처리하는 장치일 뿐이니까 말이다. 우리의 목표는 이 스트림을 관찰(Observe)하고 필요한 경우 특정한 데이터로 변환하는 것이다.</p>\n<p>반응형 프로그래밍라는 것은 사실 자바스크립트에겐 완전히 새로운 것은 아니다. 이미 프로퍼티 바인딩이라던지 혹은 이벤트 이미터 패턴이나 노드 제이에스의 스트림같은 것들을 다뤄 왔기 때문이다. 가끔 이런 우아한 방법들은 성능의 저하나 지나치게 복잡한 추상 혹은 디버깅상의 문제로 이어지게 될 때가 있다. 보통 이러한 단점들은 새로운 추상 레이어가 주는 이점 덕에 무시되곤 한다. 물론 우리의 작은 예제는 일반적인 애플리케이션을 반영하고 있지는 않지만 가능한 짧고 간결해야 한다.</p>\n<p>주저하지 말고 일단 RxJS 가지고 놀아보자. RxJS는 다른 라이브러리들(jQuery 등등)에서 자주 사용하는 기술인 체이닝을 많이 사용한다. 메서드 체이닝에 관한 내용은 <a href=\"http://www.sitepoint.com/a-guide-to-method-chaining/\">SitePoint</a> 에서 확인할 수 있다.(Ruby버전)</p>\n<h2>스트림의 예</h2>\n<p>RxJS를 사용해보기 전에 나중에 작업하게 될 몇 가지 예들을 나열해보겠다. 물론 결국엔 반응형 프로그래밍과 스트림에 대한 전반적인 소개로 이어질 것이다.</p>\n<p>일반적으로 스트림은 내부와 외부 스트림으로 구분된다. 전자는 인공적으로 우리가 통제 가능한 반면 후자는 외부의 출처로부터 들어온 우리가 통제 불가능한 것이다. 외부 스트림은 우리 코드에서 직접적으로 혹은 간접적으로 발동된다.</p>\n<p>보통 스트림들은 우리를 기다려주지 않는다. 우리가 처리 가능하든 불가능하든 발생한다. 예를 들면 도로 위를 달리는 차들을 관찰(Observe) 한다고 할때 차들의 흐름을 다시 시작하게 할 수 없다는 말이다. 스트림은 우리가 스크림을 관찰하거나 혹은 아니거나 와 상관없이 발생한다. Rx 용어로 이것을 Hot observable이라고 부른다. 이와 반대로 Rx에는 Cold observables도 도입했는데 이것은 조금 더 표준적인 이터레이터처럼 동작하고 스트림에서 얻어지는 정보는 각 관찰자에 필요한 항목(item)들로 구성된다.</p>\n<p>아래의 이미지는 외부 스트림들의 예를 보여준다. HTTP 요청들과 일반적으로 설정된 웹 훅들이 있고 마찬가지로 마우스나 키보드에 의한 UI 이벤트들도 보인다. 그리고 장치에서 GPS 센서나 가속도 센서 등 여러 센서들에서 데이터를 받을 수도 있다.</p>\n<p><img src=\"//dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455228348streams.png\" alt=\"img\"></p>\n<p>이미지에는 메시지라는 스트림도 포함하고 있는데 메시지는 여러 가지 형태로 나타날 수 있다. 가장 간단한 형태는 우리의 웹사이트와 다른 웹사이트와의 커뮤니케이션이다. 다른 경우는 웹 소켓과 웹 워커와의 통신이 포함된다. 후자의 경우의 코드를 잠깐 살펴보자.</p>\n<p>워커의 코드는 바로 아래에 있다. 2부터 10의 10승까지의 소수를 구하는 코드인데 숫자가 발견되게 되면 바로 보고한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">start<span class=\"token punctuation\">,</span> end</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> n <span class=\"token operator\">=</span> start <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">++</span> <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> k <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> found <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">!</span>found <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            found <span class=\"token operator\">=</span> n <span class=\"token operator\">%</span> i <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>found<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1e10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>기본적으로, 웹 워커는 아래와 같이 사용된다.(prime.js 파일에 있다고 가정) 간결함을 위해 결과에 대한 확인코드나 웹 워커 지원에 대한 체크 코드는 생략한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token string\">'prime.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nworker<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ev</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> primeNumber <span class=\"token operator\">=</span> ev<span class=\"token punctuation\">.</span>data <span class=\"token operator\">*</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>primeNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>웹 워커에 대한 더 자세한 내용과 자바스크립트 멀티 스레딩에 관한 내용은 <a href=\"http://www.sitepoint.com/parallel-javascript-with-paralleljs/\">Parallel.js와 함께하는 자바스크립트 병령처리</a> 에서 찾아볼 수 있다.</p>\n<p>위의 예제를 잘 살펴보면 보면, 소수는 양의 정수 사이에서 점근 적 분포를 따른다는 것을 알 수 있다. x에서 무한대까지 x / log(x)의 분포를 구하게 된다. 이 말은 시작할 때 더 많은 숫자가 나타난다는 것을 뜻한다. 아래의 이미지를 보면 조금 더 이해가 수월할 수 있다.(i.e. 단위시간당 소수를 찾아내는 양이 후반보다 초반이 많다)</p>\n<p><img src=\"//dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455228353primedist.png\" alt=\"img\"></p>\n<p>관련은 없지만 사용자가 검색 창에 입력한 사용자의 입력을 봐도 유사점을 찾을 수 있다. 사용자는 검색을 위해 무언인가를 입력할 때 초반에는 빠른 속도로 입력하다가 점점 구체적인 내용이 될수록 각 키 입력 간의 시간차가 벌어지게 된다. 이때 입력에 따라 실시간으로 결과를 제공해 검색의 범위를 좁혀준다면 분명히 좋을 것 같다. 하지만 하나하나의 모든 키 입력(특히 초반에 무의식적으로 빠르게 입력되는 내용이나 충분히 상세화되지 않은 내용)에 반응을 하는 것은 원치 않는다.</p>\n<p>위 두 가지의 시나리오에서 정답은 주어진 시간 간격 동안 이전의 이벤트들을 수집하는 것이다. 두 가지 시나리오의 차이점은 구해진 소수는 주어진 시간 간격 후에는 반드시 발생해야 한다는 것이다.(i.e. 일부 소수는 지연되어 발생하더라도..) 대조적으로 검색 창은 일정한 간격 동안 키 입력이 발생하지 않은 경우에만 새 요청을 발생시킨다. 그래서 키 입력이 감지될 때마다 타이머가 리셋된다.</p>\n<h2>RxJS로 해결하기</h2>\n<p>Rx는 observable 컬렉션들을 이용해 비동기와 이벤트 기반의 프로그램을 작성하기 위한 라이브러리다. 선언적 구문과 조합성으로 잘 알려져 있으며 쉬운 시간 처리와 오류 모델을 도입했다. 위에서 다루웠던 예제에선 특히 시간 처리에 관한 내용이었는데 RxJS를 이용하면 시간처리 말고도 다양한 이득을 얻을 수 있다.</p>\n<p>RxJS의 기본 구성 요소는 생산자인 observables와 소비자인 observers로 구성된다. 이미 두 가지의 observables의 두 가지 유형에 대해서는 언급했었다.</p>\n<ul>\n<li><strong>Hot observables</strong> 는 구독을 하고 있지 않아도 발생된다.(e.g, UI 이벤트)</li>\n<li><strong>Cold observables</strong> 는 구독을 할때만 발생한다. 구독을 다시 시작하면 다시 발생된다.</li>\n</ul>\n<p>Cold observables는 일반적으로 RxJS 안에서 사용되도록 변환된 배열이나 단일 값들을 나타낸다. 예를 들어 다음의 코드는 완료하기 전에 하나의 값만 생성하는 Cold observable 객체를 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> observable <span class=\"token operator\">=</span> Rx<span class=\"token punctuation\">.</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">observer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    observer<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    observer<span class=\"token punctuation\">.</span><span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한 observable 생성 함수에서 로직이 포함된 함수를 리턴할 수도 있다.</p>\n<p>observable을 구독(subscribe) 하는 것은 observable의 종류(Cold, Hot)와 상관없이 동일하다. 구독할 때는 두가지 타입 모두 알림을 위한 문법인 onNext, onError 그리고 onComplete 이렇게 세 가지의 함수를 기본적으로 제공할 수 있는데 이중 onNext 콜백은 필수 요소다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> subscription <span class=\"token operator\">=</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Next: %s.'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ev</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Error: %s!'</span><span class=\"token punctuation\">,</span> ev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Completed!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsubscription<span class=\"token punctuation\">.</span><span class=\"token function\">dispose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>구독을 종료하는 가장 좋은 방법은 <strong>dispose</strong> 메서드를 이용하는 것이다. 이렇게 하면 필요한 정리 절차를 진행하게 된다. 그렇지 않으면 사용되지 않으면서 가비지 컬렉션도 되지 않는 자원으로 남을 수 있다.</p>\n<p>구독하지 않으면 변수 observable 안에 포함 된 observable은 그저 Cold observable일 뿐이다. 그렇지만 <strong>publish</strong> 메소드를 이용해서 핫 시퀀스(i.e. 의사 구독을 수행)로 변환할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> hotObservable <span class=\"token operator\">=</span> observable<span class=\"token punctuation\">.</span><span class=\"token function\">publish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>RxJS에 포함된 일부 헬퍼들은 단지 기존 데이터 구조의 변환만 다룬다. 자바스크립트에서는 이들을 세 가지로 구분할 수 있다.</p>\n<ol>\n<li><strong>프로미스</strong> 는 한 개의 비동기 결과를 리턴하기 위해 사용된다.</li>\n<li><strong>함수</strong> 는 한 개의 결과를 위해 사용되고,</li>\n<li><strong>제너레이터</strong> 는 이터레이터를 제공하기 위해 사용된다.</li>\n</ol>\n<p>제너레이터는 ES6에서 새로 나왔는데 ES5나 이전 버전의 배열(나쁘진 않지만 한 개의 값으로 취급되어야 한다)을 대체할만한 기능이다.</p>\n<p>RxJS는 비동기 다중(반환) 값을 지원하는 데이터 유형을 제공한다. 그래서, 4개의 사분면이 이제 채워진다.</p>\n<p><img src=\"//dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455228358pillars.png\" alt=\"img\"></p>\n<p>이터레이터의에서는 값을 당겨(pull)오는 반면 observables의 값들은 밀어(push) 넣어 진다. 예제로 대뤄질 내용은 이벤트 스트림인데 다음 이벤트를 강제로 발생시킬 수 없고 그저 이벤트 루프에서의 통보(notify)를 기다릴 수 밖에 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> source <span class=\"token operator\">=</span> Rx<span class=\"token punctuation\">.</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Observables를 생성하고 다루는 대부분의 헬퍼들은 스케쥴러를 적용할 수 있다. 스케줄러는 언제 구독이 시작되고 언제 통보(notifications)가 발행(publish) 될지를 조종한다. 기본 스케줄러가 실 사용시 대부분의 경우에서 잘 동작하기 때문에 여기서는 스케줄에 관해 자세히 다루지는 않을 것이다.</p>\n<p>RxJS의 많은 오퍼레이터들은 스로틀이나 인터벌 혹은 딜레이 같은 동시성을 도입한다. 이제 이전의 예제를 다시 한 번 살펴보자 이제 이러한 헬퍼들이 필수적으로 된다.</p>\n<h2>예제</h2>\n<p>먼저 소수 발생기부터 살펴보자. 이제 주어진 시간의 결과들을 모와서 UI가 너무 많이 업데이트 되지 않도록 할 것이다.(특히 시작 시점에)</p>\n<p>여기서는 앞서 언급했던 인터벌 헬퍼와의 연결을 통해 RxJS의 버퍼 함수를 사용하려고 한다.</p>\n<p>결과는 아래의 이미지의 다이어그램이 보여주고 있다. 녹색원은 일정한 간격(소요시간) 후에 발생하고 버퍼는 그 간격 동안 발생한 파란색의 원만큼 수집한다.(역. 파란색원 = 소수 발생)</p>\n<p><img src=\"//dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455228367buffer.png\" alt=\"img\"></p>\n<p>또한 맵을 이용해 데이터를 변환할 수 있다. 예를 들어, 수신된 이벤트 인수를 변형해 수신된 데이터를 숫자로 변환 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token string\">'prime.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> observable <span class=\"token operator\">=</span> Rx<span class=\"token punctuation\">.</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">fromEvent</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ev</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> ev<span class=\"token punctuation\">.</span>data <span class=\"token operator\">*</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">buffer</span><span class=\"token punctuation\">(</span>Rx<span class=\"token punctuation\">.</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">where</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>fromEvent 함수는 표준 이벤트 이미터 패턴을 이용해 모든 오브젝트로부터 observable를 생성한다. 버퍼는 길이가 0인 배열을 리턴할 수 있으니 where 함수를 이용해 길이가 0인 스트림은 제외한다. 마지막으로 이 예제에서는 단 소수의 생성 횟수에만 관심이 있으니 map을 이용해 버퍼의 개수를 얻어 온다.</p>\n<p>다른 예제는 일정한 시간 후에 요청을 시작하도록 제한해야 하는 검색 쿼리 상자다. 이런 시나리오에서는 사용할 수 있는 함수가 두가지가 있는데 <strong>throttle</strong> 함수는 지정된 타임 윈도우동안 실행을 지연하는데 첫 요청만 수행하고 지연하고 <strong>debounce</strong> 함수는 타임 윈도우가 흐른 후 마지막에 한번 수행해준다. 그 타임 윈도우 역시 각 펑션에 따라 일정하게 미뤄진다.</p>\n<p>여기서는 아래의 다이어그램이 보여주는 동작이 필요하다 그래서 여기서는 디바운스 매커니즘을 사용할 것이다.</p>\n<p><img src=\"//dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/1455228362debounce.png\" alt=\"img\"></p>\n<p>이전의 결과들은 모두 버리고 마지막 타임 윈도우가 끝나기 직전 마지막 것만 취하게 된다. 입력 필드에 id 쿼리가 있다고 한다면 아래의 코드를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> q <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#query'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> observable <span class=\"token operator\">=</span> Rx<span class=\"token punctuation\">.</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">fromEvent</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token string\">'keyup'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">debounce</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ev</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> ev<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">where</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">.</span>length <span class=\"token operator\">>=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">distinctUntilChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>searchFor<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">switch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">where</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> obj <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드에서는 타임 윈도우의 시간을 300ms로 정했다. 또한 이전 쿼리하고는 다른 최소 3개의 문자로 제한한다. 이렇게 하면 텍스트를 지우거나 수정할 때의 불필요한 요청을 제거할 수 있다.</p>\n<p>전체 표현 중에는 두 가지의 중요한 부분이 있다. 하나는 <strong>searchFor</strong> 함수를 이용해 쿼리 텍스트를 요청으로 변환하는 부분이고 나머지 하나는 <strong>switch</strong> 함수다. <strong>switch</strong> 함수는 네스트된 observable들을 리턴하는 함수를 받아 가장 최근의 observable 시퀀스에서만 값을 생성한다.</p>\n<p>요청을 만드는 함수는 아래와 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">searchFor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    xhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> apibaseUrl <span class=\"token operator\">+</span> <span class=\"token string\">'?q='</span> <span class=\"token operator\">+</span> text<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    xhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Rx<span class=\"token punctuation\">.</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">fromEvent</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">,</span> <span class=\"token string\">'load'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ev</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> request <span class=\"token operator\">=</span> ev<span class=\"token punctuation\">.</span>currentTarget<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">var</span> response <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>responseText<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>switch함수에 where함수를 연결하는 이유는 네스트된 observable의 잘못된 요청으로 undefined가 될 수 있기 때문이다.</p>\n<h2>결론</h2>\n<p>RxJS는 javascript에서 즐거운 반응형 프로그래밍을 할 수 있게 해준다. 대안으로 유사하게 동작하는 Bacon.js도 있다. 그래도 RxJS의 가장 좋은 점은 바로 Rx라는 점 그 자체다. 많은 플랫폼에서 사용 가능하며 이로 인해서 다른 언어, 플랫폼 혹은 시스템으로 쉽게 전환할 수 있다. 그리고 갈결하고 조합 가능한 일련의 메서드의 사용으로 반응형 프로그래밍의 개념을 통합한다. 또한 DOM 과의 상호 작용을 단순화하는 RxJS-DOM과 같은 몇 가지 매우 유용한 확장들도 존재한다.</p>\n<p>Where do you see RxJS shine?</p>","fields":{"slug":"/2017-01-03-RxJS와 함께하는 함수형 리액티브 프로그래밍/"},"excerpt":"원글: https://www.sitepoint.com/functional-reactive-programming-rxjs/ RxJS와 함께하는 함수형 반응형 프로그래밍 이 글은 Moritz Kröger, Bruno Mota와 Vildan Softic의 검수를 받았다. SitePoint의 컨텐트들이 최고가 될 수 있게 도와주는 SitePont의 모든 동료 리뷰어들에게 감사를 표한다. 본론으로 들어가기 전에 한가지 중요한 질문을 던져 본다. \"반응형 프로그래밍이란 무엇인가?\" 지금 시점에서 가장 일반적인 답변은 \"반응형 프로그래밍은 동…","frontmatter":{"title":"RxJS와 함께하는 함수형 리액티브 프로그래밍","date":"03 January, 2017","categories":"designpattern, javascript, translation","image":null,"imageAuthor":null,"imageAuthorLink":null,"imageFromLink":null,"imageFrom":null}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-08-14-Vue.js에서의 다이나믹 컴포넌트 템플릿/"},"frontmatter":{"title":"Vue.js에서의 다이나믹 컴포넌트 템플릿","categories":"framework, translation","date":"14 August, 2018"},"excerpt":"원글: https://medium.com/scrumpy/dynamic-component-templates-with-vue-js-d9236ab183bb Vue.js에서의 다이나믹 컴포넌트 템플릿 컴포넌트들이 항상 같은 구조로 되어 있진 않다. 그리고 때론 관리해야할 상태들이 많을때도 있다. 이런 문제는 비동기적인 방법으로 해결할 수도 있다. 유즈 케이스 스크럼피는 알림, 댓글, 첨부 파일 등에서 컴포넌트 템플릿을 사용한다. 우선 댓글 부분을 살펴보면서 정확히 어떤 것을 말하는지 알아보자. 최근의 댓글은 더 이상 단순한 텍스트 필드가…"},{"fields":{"slug":"/2018-07-10-요즘 잘나가는 프론트엔드 개발환경 만들기(2018) ES6/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6","categories":"frontend, javascript","date":"10 July, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6 본 시리즈의  이전 아티클에서는 웹팩4에 대해 다루면서 바로 쓸 수 있는 환경을 만들어봤다. 이번편에는 그 환경 그대로 이용해 ES6 개발 환경을 추가한다. ES6는 이제 충분히 써도 될만한 시기라고 생각한다. \"나는 프런트 개발자가 아니기도 하고 브라우저가 모두 지원하지도 않기에 ES6는 아직 못쓴다\" 라고 생각하고 있다면 이 글을 통해 생각을 바꿀 수 있길 바란다. 어차피 쓰는 거 ES6뿐 아니라 ES8까지 사용하는 것을 권장한다. IE11 이하 버전들은 ES6나 이…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2021-05-17/"},"frontmatter":{"title":"개발을 잘 하는 습관","categories":"developer, habbit","date":"17 May, 2021"},"excerpt":"저는 반복적으로 하는 작업이 있다면 가장 나에게 맞는 최적화된 루틴을 만들고 그 작업을 할 때마다 생각 없이 그대로 하는 편이에요. 정해진 루틴은 고집스럽게 유지하진 않고요. 경험에 따라 혹은 관련 지식이 늘어남에 따라 루틴을 조금씩 개선합니다. 루틴은 “현재 내가 이 일을 잘 하기 위해 알고 있는 위한 가장 나은 방법”이라고 할 수 있겠네요. 그리고 실행할 때는 이 생각 저 생각 할 필요 없이 그냥 실행합니다. 각 단계에 대한 생각만 하는 것이죠. 예를 들어 제가 사는 아파트는 매주 한 번 재활용 수거를 하는데 재활용을 할 때도…"},{"fields":{"slug":"/2021-04-20/"},"frontmatter":{"title":"욕 안 먹는 개발자되기","categories":"developer","date":"20 April, 2021"},"excerpt":"직장인이라면 자연스럽게 업무를 대하는 태도가 캐릭터 처럼 만들어져요. 개발자도 마찬가지고요. 신입이라고 태도가 항상 나쁜 것도 아니고 경력이라고 항상 태도가 좋은 것도 아니에요. 코딩 스킬처럼 개선될 수도 있고요. 연차가 적을수록 몰라서 잘못된 태도를 갖는 경우가 많습니다. 이렇게 만들어진 태도는 보통 연차가 높을수록 개선되기 힘들다고들 하죠. 태도라는 큰 추상적인 덩어리는 억울하게도 한 부분, 한 사건에 의해 모든 것을 퉁쳐서 판단되기도 하죠. 이런 태도의 중요한 한 부분은 업무 중 문제가 발생했을 때에 뚜렷하게 나타난다고 생각…"},{"fields":{"slug":"/2021-02-22/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 2","categories":"frontend, nodejs, tdd","date":"22 February, 2021"},"excerpt":"파트 1에서는 기본 자바스크립트 개발 환경을 러나와 함께 구축해봤어요. 기본 환경만으로 충분하신 분들도 계시겠지만 보통은 그렇지 않을 겁니다.\n이제 두 가지 개발 환경을 추가할 건데요. 타입 스크립트와 리액트 개발 환경이에요. 우선 타입스크립트 환경을부터 추가할 거예요. 그전에 러나로 해줘야 할 작업이 있습니다. 타입스크립트 환경도 결국 지금까지 저희가 구축한 자바스크립트 환경 위에 만들어질 것이기 때문에 디펜던시 모듈을 공유할 수 있도록 만들고 환경 설정 파일들도 기본 자바스크립트의 환경설정 파일들을 확장해서 사용할 거예요. 그…"},{"fields":{"slug":"/2021-02-15/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 1","categories":"frontend, nodejs, tdd","date":"15 February, 2021"},"excerpt":"개발을 하다 보면 특정 환경에서 빠르게 코드를 작성하고 그 결과를 확인해보고 싶을 때가 있어요. 라이브러리나 프레임웍 혹은 언어를 공부할 때나 아이디어를 빠르게 실험하거나 프로토타입 해보고 싶을 때 그렇지요. 바닐라 자바스크립트로 충분한 환경이라면 디렉터리 하나 만들고 js 파일 하나 html 파일 하나 만들어서 에디터를 열고 브라우저를 열어서 html 파일을 불러오는 것까지 하면 기본적인 준비가 끝나요. 근데요. 이런 바닐라 자바스크립트 환경을 만드는 것조차도 사실 귀찮을 때가 있어요. 이런 기본 환경도 귀찮은데 실무의 복잡한 …"},{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"developer, recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"}]}},"pageContext":{"slug":"/2017-01-03-RxJS와 함께하는 함수형 리액티브 프로그래밍/","categoriesRegex":"/designpattern|javascript|translation/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}