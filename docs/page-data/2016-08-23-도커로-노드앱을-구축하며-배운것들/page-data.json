{"componentChunkName":"component---src-templates-post-tsx","path":"/2016-08-23-도커로-노드앱을-구축하며-배운것들/","result":{"data":{"markdownRemark":{"html":"<h2>도커로 노드 앱을 구축하며 배운것들</h2>\n<blockquote>\n<p>원문\n<a href=\"http://jdlm.info/articles/2016/03/06/lessons-building-node-app-docker.html\">http://jdlm.info/articles/2016/03/06/lessons-building-node-app-docker.html</a>\nby John Lees-Miller</p>\n</blockquote>\n<p><a href=\"https://www.docker.com/\">도커</a>를 이용해 노드제이에스 어플리케이션을 개발 하고 배포 하면서 어렵게 배운 팁과 트릭을 공유하고자 한다.</p>\n<p>이 튜토리얼 아티클에서는 <a href=\"http://socket.io/get-started/chat/\">socket.io chat example</a>을 이용해 기초부터 프로덕션에 응용 가능한 상태까지 될 수 있으면 쉽게 이해할 수 있도록 설명하려 한다.</p>\n<p>아래와 같은 내용을 다룬다.</p>\n<ul>\n<li>도커를 이용해 노드 어플리케이션을 시작하는 방법</li>\n<li>모든것을 루트로 실행 하지 않기(BAD!)</li>\n<li>개발시에 테스트-수정-리로드 사이클을 짧게 유지하기 위해 바인드를 이용하는 방법</li>\n<li>컨테이너에서 빠르게 리빌드를 하기위한 <code class=\"language-text\">node_modules</code> 관리(이렇게 할 수 있는 트릭이 있다)</li>\n<li><a href=\"https://docs.npmjs.com/cli/shrinkwrap\">npm shirinkwrap</a>를 이용한 반복적인 빌드</li>\n<li>개발환경과 프로덕션환경에서의 <code class=\"language-text\">Dockerfile</code> 공유</li>\n</ul>\n<p>이 튜토리얼은 도커나 노드제이에스에 약간 익숙한 사람들을 대상으로 작성되었다. 만약 도커에 대한 약간의 사전 지식을 알고 싶다면 <a href=\"http://jdlm.info/ds-docker-demo/\">도커에 대한 슬라이드를 참고</a>하거나 아니면 여기 저기 많이 널려있는 도커관련 아티클들을 참고하면 된다.</p>\n<h3>Getting Started</h3>\n<p>일단 아무것도 없는 상태에서 시작해보자. 만들고자 하는 최종적인 코드는 <a href=\"https://github.com/jdleesmiller/docker-chat-demo\">여기</a>에 있다. 그리고 진행될 각 스텝에 해당하는 태그들이 있다.</p>\n<p>도커가 없다면 호스트에 노드와 필요한 디펜던시들을 설치 하는것을 시작으로 <code class=\"language-text\">npm init</code> 으로 새로운 패키지를 만들어야 한다. 이런 작업을 피할 수 없지만 시작부터 도커를 이용한다면 이야기는 달라진다. (그리고 어떤것도 호스트에 설치할 필요가 없는것은 도커의 큰 장점이다.) 그래서 node가 이미 설치되어 있는 “bootstrapping container”를 만드는 것으로 시작을 한다. 그리고 이것으로 어플리케이션을 위한 npm 패키지를 설정한다.</p>\n<p>두개의 파일을 작성 해야하는데 <code class=\"language-text\">Dockerfile</code>과 <code class=\"language-text\">docker-compose.yml</code>이다. 이 파일들은 나중에 계속 내용을 추가 할 것이다. <code class=\"language-text\">Dockerfile</code>부터 시작하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM node:4.3.2\n\nRUN useradd --user-group --create-home --shell /bin/false app &amp;&amp;\\\n  npm install --global npm@3.7.5\n\nENV HOME=/home/app\n\nUSER app\nWORKDIR $HOME/chat</code></pre></div>\n<p>이 파일은 상대적으로 짧다. 하지만 이미 중요한 포인트들은 모두 가지고 있다.</p>\n<ol>\n<li>현 시점에서 가장 최신 버전의 공식 장기 지원(LTS) 도커이미지로 시작을 한다. 나는 <code class=\"language-text\">node:argon</code>이나 <code class=\"language-text\">node:latest</code>같은 유동적인 테그네임보다는 명확한 버전을 표기하는 것을 선호한다. 당신 혹은 누군가를 위해 이 이미지를 다른 머신에 빌드할때 동일한 버전을 사용할 수 있고 버전 차이로 인한 여러가지 문제를 피할 수 있다.</li>\n<li>컨테이너 안에서 앱을 실행하기 위해 단순하게 <code class=\"language-text\">app</code>이라는 기본적인 권한의 유저를 만든다. 이렇게 하지 않으면 컨테이너 안의 모든 프로세스들은 루트권한으로 실행되게 되는데 이렇게 되면 보안상의 베스트 프랙티스와 <a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\">원칙</a>에 어긋나게 된다. 많은 튜토리얼들이 단순함을 위해 이 단계를 건너뛰고 있고 이 일을 하기 위해선 추가적으로 해야할 일이 있지만 나는 이 작업이 매우 중요하다고 생각한다.</li>\n<li>가장 최근 버전의 NPM을 설치 한다. 이건 반드시 필요한 작업은 아니지만 NPM 최근 많은 부분에서 발전이 있었고 특히 <code class=\"language-text\">npm shrinkwrap</code> 지원은 더 나아졌다.(shrinkwrap에 대한 더 자세한 것들은 곧 다룬다.) 다시 말하지만 추후 빌드중에 의도치 않은 업그레이드를 피하기 위해 꼭 명확한 버전을 Dockerfile에 명시하는것이 최선이라고 생각한다.</li>\n<li>마지막으로 하나의 <code class=\"language-text\">RUN</code> 명령당 두 개의 쉘 명령을 연결한다. 이것은 결과 이미지에 레이어 수를 줄여준다. 이 예제에서는 크게 중요해 보이지는 않지만 필요 이상의 레이어를 사용하지 않는 것은 <a href=\"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/\">좋은 습관</a>이다. 이렇게 하면 패키지를 다운로드하거나 압축을 풀고, 빌드를 하고, 설치를 할때 사용되는 디스크 용량과 다운로드 시간을 아낄 수 있다. 그래서 각 스텝별로 중간 파일을 만들지 않고 한 스텝으로 정리할 수 있다.</li>\n</ol>\n<p>자, 이제 <code class=\"language-text\">docker-compose.yml</code> 을 구성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chat:\n  build: .\n  command: echo &#39;ready&#39;\n  volumes:\n    - .:/home/app/chat</code></pre></div>\n<p>이 파일은 <code class=\"language-text\">Dockerfile</code>에 의해 만들어지는 한개의 서비스를 정의 한다. 이것이 하는 일은 <code class=\"language-text\">ready</code>를 echo 하고 종료하는 것 밖에 없다. 불륨 라인의 <code class=\"language-text\">.:/home/app/chat</code>는 도커에게 호스트의 어플리케이션 폴더 <code class=\"language-text\">.</code>을 컨테이너 안쪽의 <code class=\"language-text\">/home/app/chat</code>에 마운트하게 해 호스트의 소스파일이 자동적으로 컨테이너 안쪽으로 반영되도록 하게 한다. (상호 반영됨) 개발중에 test-edit-reload 사이클을 가능한 짧게 유지하는 것은 매우 중요하지만 NPM이 디펜던시 모듈들을 설치할 때 이슈를 만들게 된다. 이것에 대해서는 곧 다시 다루게 된다.</p>\n<p>아무튼 지금까지는 잘 진행된다. docker-compose를 실행하게 되면 도커는 이미지를 만들어 Dockerfile에 정의된 내용대로 노드를 셋업하게 되고 그 이미지와 함께 컨테이너를 시작한 뒤 모든게 정상이라고 OK를 보여주는 echo 명령을 <code class=\"language-text\">RUN</code>한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose up\nBuilding chat\nStep 1 : FROM node:4.3.2\n ---&gt; 3538b8c69182\n...\nlots of build output\n...\nSuccessfully built 1aaca0ac5d19\nCreating dockerchatdemo_chat_1\nAttaching to dockerchatdemo_chat_1\nchat_1 | ready\ndockerchatdemo_chat_1 exited with code 0</code></pre></div>\n<p>그리고 이제 같은 이미지로 부터 만들어진 컨테이너 안의 인터렉티브 쉘을 실행한 뒤 초기 패키지 파일을 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose run --rm chat /bin/bash\napp@e93024da77fb:~/chat$ npm init --yes\n... writes package.json ...\napp@e93024da77fb:~/chat$ npm shrinkwrap\n... writes npm-shrinkwrap.json ...\napp@e93024da77fb:~/chat$ exit</code></pre></div>\n<p>그리고 호스트에 작업한 파일들을 버전 컨트롤 시스템에 커밋할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ tree\n.\n├── Dockerfile\n├── docker-compose.yml\n├── npm-shrinkwrap.json\n└── package.json</code></pre></div>\n<p><a href=\"https://github.com/jdleesmiller/docker-chat-demo/tree/02-bootstrapped\">여기</a> 에서 지금까지 만들어진 코드들을 확인할 수 있다.</p>\n<h3>디펜던시 설치</h3>\n<p>다음에 할 일은 앱의 디펜던시들을 설치하는 것이다. <code class=\"language-text\">docker-compose up</code>을 처음 실행하면 앱이 실행될 준비를 하기 위해 <code class=\"language-text\">Dockerfile</code>의 내용대로 컨테이너에 디펜던시들이 설치된다.</p>\n<p>그렇게 하기 위해 <code class=\"language-text\">Dockerfile</code>의 <code class=\"language-text\">npm install</code>을 실행하기 전에 <code class=\"language-text\">package.json</code>과 <code class=\"language-text\">npm-shrinkwrap.json</code> 파일을 이미지 안으로 복사한다. 아래는 복사를 위한 Dockerfile의 change 정보이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diff --git a/Dockerfile b/Dockerfile\nindex c2afee0..9cfe17c 100644\n--- a/Dockerfile\n+++ b/Dockerfile\n@@ -5,5 +5,9 @@ RUN useradd --user-group --create-home --shell /bin/false app &amp;&amp;\\\n\n ENV HOME=/home/app\n\n+COPY package.json npm-shrinkwrap.json $HOME/chat/\n+RUN chown -R app:app $HOME/*\n+\n USER app\n WORKDIR $HOME/chat\n+RUN npm install</code></pre></div>\n<p>다시 약간의 변화를 주었지만 몇가지 중요한 포인트가 있다.</p>\n<ol>\n<li><code class=\"language-text\">COPY</code> 명령을 통해 어플리케이션 전체를 호스트에서 <code class=\"language-text\">$HOME/chat</code>으로 복사할 수 있지만 우리는 패키징 파일들만 복사하게 된다. 이렇게 우리가 필요로 하는 파일만 복사하고 <code class=\"language-text\">npm install</code>을 통해서 나머지를 카피하는 것이 도커 빌드시 시간적인 장점이 있다는 것을 추후 알 수 있게 된다. 이것은 <code class=\"language-text\">docker build</code>의 레이어 캐싱의 장점을 더 잘 활용하는 것이다.</li>\n<li><code class=\"language-text\">COPY</code> 명령을 통해 컨테이너로 복사된 파일들은 결과적으로 root가 소유하게 되어 우리의 비특권유저인 <code class=\"language-text\">app</code> 이 읽거나 쓰지 못하게 한다. 그래서 카피한 이후 간단히 <code class=\"language-text\">chown</code> 명령을 이용해 사용을 허가할 수 있다.(<code class=\"language-text\">USER app</code> 단계 이후에 <code class=\"language-text\">COPY</code>를 수행해서 <code class=\"language-text\">app</code> 유저로 파일 카피를 수행하면 더 좋을 것 같지만 <a href=\"https://github.com/docker/docker/issues/6119\">아직은 불가능하다.</a></li>\n<li>마지막으로 <code class=\"language-text\">npm install</code>을 끝에 추가한다. 이 명령은 <code class=\"language-text\">app</code> 유저로 실행되어 <code class=\"language-text\">$HOME/chat/node-modules</code>에 디펜던시들을 컨테이너에 설치하게 된다. (추가적으로 <code class=\"language-text\">npm cache clean</code>을 추가하여 NPM이 인스톨중에 다운로드한 tar파일들을 지우는 게 좋다. 이 파일들은 이미지를 다시 빌드할 때 아무런 도움이 되지 않으니 공간을 더 확보하는 편이 좋다.)</li>\n</ol>\n<p>마지막 내용은 개발시 이미지를 사용할 때 몇몇 문제의 원인이 된다. 왜냐하면 <code class=\"language-text\">$HOME/chat</code>을 컨테이너에서 호스트의 어플리케이션 폴더로 바인드 했기 때문이다. 바인드로 인해 불행히도 우리가 인스톨한 <code class=\"language-text\">node_modules</code>를 효과적으로 숨겨주기 때문에 <code class=\"language-text\">node_modules</code> 폴더는 호스트에 존재하지 않게 된다.</p>\n<h3><code class=\"language-text\">node_modules</code> 불륨 트릭</h3>\n<p>이 문제를 해결하기 위해 <a href=\"http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/\">여러가지 방법</a>이 있지만 내 생각에 가장 우아한 <a href=\"http://stackoverflow.com/questions/30043872/docker-compose-node-modules-not-present-in-a-volume-after-npm-install-succeeds\">방법</a>은 불륨을 바인드안에서 <code class=\"language-text\">node_modules</code>를 포함하도록 하는 것이다. 이렇게 하기 위해선 도커 컴포즈파일 끝부분에 라인 한줄만 추가하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diff --git a/docker-compose.yml b/docker-compose.yml\nindex 9e0b012..9ac21d6 100644\n--- a/docker-compose.yml\n+++ b/docker-compose.yml\n@@ -3,3 +3,4 @@ chat:\n   command: echo &#39;ready&#39;\n   volumes:\n     - .:/home/app/chat\n+    - /home/app/chat/node_modules</code></pre></div>\n<p>적용하는 것은 간단하지만 이렇게 하기 위해 내부적으로는 꽤 작업이 수행된다.</p>\n<ol>\n<li>\n<p>빌드를 할때, <code class=\"language-text\">npm install</code>은 디펜던시들을(다음 섹션에서 추가하게됨) 이미지 내의 <code class=\"language-text\">$HOME/chat/node_modules</code>에 인스톨한다. 이미지의 파일들을 파란색으로 표현했다.(역: 마크다운 문법으로 인해 색은 생략함, 아래 코드블럭내용이 모두 파란색)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">~/chat$ tree # in image\n.\n├── node_modules\n│   ├── abbrev\n...\n│   └── xmlhttprequest\n├── npm-shrinkwrap.json\n└── package.json</code></pre></div>\n</li>\n<li>\n<p>추후 컴포즈파일을 이용해 이미지에서 컨테이너를 시작하게 되면 도커는 호스트의 어플리케이션 폴더를 컨테이너의 <code class=\"language-text\">$HOME/chat</code> 안으로 바인드한다. 호스트의 파일은 빨간색으로 표현했다.(역: 상동)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">~/chat$ tree # in container without node_modules volume\n.\n├── Dockerfile\n├── docker-compose.yml\n├── node_modules\n├── npm-shrinkwrap.json\n└── package.json</code></pre></div>\n</li>\n</ol>\n<p>불행히도 컨테이너 내의 <code class=\"language-text\">node_modules</code>는 바인드에 의해 숨겨지기 때문에 호스트에 보이는 것은 빈 <code class=\"language-text\">node_modules</code> 이다.</p>\n<ol start=\"3\">\n<li>\n<p>그러나 아직 끝난 게 아니다. 다음으로 도커는 이미지 안의 <code class=\"language-text\">$HOME/chat/node_modules</code>를 가지고 있는 불륨을 생성하고 컨테이너에 마운트한다. 그리고 이는 다시 호스트의 바인드로부터 숨겨진다.\n(역: 다 빨간색이고 node_modules과 하위만 파란색)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">~/chat$ tree # in container with node_modules volume\n.\n├── Dockerfile\n├── docker-compose.yml\n├── node_modules\n│   ├── abbrev\n...\n│   └── xmlhttprequest\n├── npm-shrinkwrap.json\n└── package.json</code></pre></div>\n</li>\n</ol>\n<p>이제 우리가 원하는 것을 얻었다. 호스트의 우리의 소스파일들은 컨테이너 안으로 바인드되어 빠른 수정을 가능케하는 반면 디펜던시들은 컨테이너 안에 있어 앱을 실행할때 사용할 수 있다.</p>\n<p>(추가팁: 아마도 이런 디펜던시 파일들이 실제로 어디에 저장되어 있는지 궁금할 것이다. 짧게 말하면 도커에 의해 관리되는 분리된 호스트의 디렉터리에 있다. 더 자세한 정보는 <a href=\"https://docs.docker.com/engine/tutorials/dockervolumes/\">여기</a>에서 확인할 수 있다.</p>\n<h3>패키지 설치 그리고 Shrinkwrap</h3>\n<p>이제 이미지를 다시 빌드해 패키지를 설치해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose build\n... builds and runs npm install (with no packages yet)...</code></pre></div>\n<p>채팅앱은 express버전 4.10.2가 필요하다. <code class=\"language-text\">npm install</code>을  <code class=\"language-text\">—save</code>옵션과 함께 실행 하여 <code class=\"language-text\">package.json</code>에 기록하고 <code class=\"language-text\">npm-shrinkwrap.json</code>도 업데이트한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose run --rm chat /bin/bash\napp@9d800b7e3f6f:~/chat$ npm install --save express@4.10.2\napp@9d800b7e3f6f:~/chat$ exit</code></pre></div>\n<p>꼭 정확한 버전을 명시할 필요는 없다. 그냥 <code class=\"language-text\">npm install —save express</code>로 어떤 버전이던 최종버전으로 설치해도 좋다. package.json과 shrinkwrap은 이렇게 설치해도 해당 버전으로 기록이 되기 때문이다.</p>\n<p>npm의 shrinkwrap 기능을 이용하는 이유는 직접적인 디펜던시의 버전들은 package.json통해서 고정할 수 있는 반면 그 디펜던시들의 디펜던시들은 고정할 수 없기 때문이다.(루즈하게 명시된 버전의 경우) 이 말은 나중에 누군가가 이미지를 다시 빌드할때 간접적인 디펜던시들의 버전이 다름으로 인해 앱이 깨지는것에 대해 보장 할 수 없다는 말이다. 나에겐 생각보다 자주 발생했다. 그래서 shrinkwrap을 사용하는것을 권장한다. 만약 당신이 루비의 훌륭한 <a href=\"http://bundler.io/\">bundler</a> 디펜던시 매니저에 익숙하다면 <code class=\"language-text\">npm-shrinkwrap.json</code>은 <code class=\"language-text\">Gemfile.lock</code>과 같다고 보면 된다.</p>\n<p>마지막으로 주목해야 할 내용은 우리는 일회성으로 <code class=\"language-text\">docker-compose run</code>에 의해 컨테이너를 실행하기 때문에 실질적으로 우리가 설치한 모듈들은 사라진다. 하지만 다음에 도커빌드를 다시 실행하면 도커는 <code class=\"language-text\">package.json</code>와 shrinkwrap의 변경을 감지하고 <code class=\"language-text\">npm install</code>을 다시 실행해 필요한 패키지가 이미지에 설치된다.(매우 중요한 점이다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose build\n... lots of npm install output\n$ docker-compose run --rm chat /bin/bash\napp@912d123f3cea:~/chat$ ls node_modules/\naccepts              cookie-signature  depd ...\n...\napp@912d123f3cea:~/chat$ exit</code></pre></div>\n<p><a href=\"https://github.com/jdleesmiller/docker-chat-demo/tree/03-dependencies\">여기</a> 에 지금까지의 코드가 있다.</p>\n<h3>앱을 실행하기</h3>\n<p>우리는 드디어 앱을 설치할 준비가 되었다. <a href=\"https://github.com/rauchg/chat-example\">남아있는 소스파일들</a> <code class=\"language-text\">index.js</code>와 <code class=\"language-text\">index.html</code>을 설치한다. 그리고 <code class=\"language-text\">socket.it</code> 패키지를 이전 섹션에서 한 것처럼 <code class=\"language-text\">npm install —save</code>를 이용해 설치한다.</p>\n<p>우리의 <code class=\"language-text\">Dockerfile</code>에서 이미지를 이용해 컨테이너를 시작할 때 어떤 커맨드를 실행해야 하는지 알려줄 수 있고 이 경우엔 <code class=\"language-text\">node index.js</code>가 된다. 도커 컴포즈파일에서 더미 커맨드를 지워 도커가 <code class=\"language-text\">Dockerfile</code>을 이용해 커맨드를 실행하게 한다. 마침내 도커 컴포즈에게 호스트의 컨테이너에서 3000포트를 열게 하여 브라우저에서 엑세스 할 수 있게 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diff --git a/Dockerfile b/Dockerfile\nindex 9cfe17c..e2abdfc 100644\n--- a/Dockerfile\n+++ b/Dockerfile\n@@ -11,3 +11,5 @@ RUN chown -R app:app $HOME/*\n USER app\n WORKDIR $HOME/chat\n RUN npm install\n+\n+CMD [&quot;node&quot;, &quot;index.js&quot;]\ndiff --git a/docker-compose.yml b/docker-compose.yml\nindex 9ac21d6..e7bd11e 100644\n--- a/docker-compose.yml\n+++ b/docker-compose.yml\n@@ -1,6 +1,7 @@\n chat:\n   build: .\n-  command: echo &#39;ready&#39;\n+  ports:\n+    - &#39;3000:3000&#39;\n   volumes:\n     - .:/home/app/chat\n     - /home/app/chat/node_modules</code></pre></div>\n<p>그리고 마지막 빌드를 하고  <code class=\"language-text\">docker-compose up</code> 실행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose build\n... lots of build output\n$ docker-compose up\nRecreating dockerchatdemo_chat_1\nAttaching to dockerchatdemo_chat_1\nchat_1 | listening on *:3000</code></pre></div>\n<p>그리고 (맥의 경우 boot2docker VM에서 3000포트를 사용할 수 있게 하기 위해 몇가지 작업을 해야한다.) <code class=\"language-text\">http://localhost:3000</code> 에서 앱이 동작하는것을 볼 수 있다.</p>\n<p><img src=\"http://jdlm.info/assets/docker_chat_demo/chat.png\" alt=\"실행화면\"></p>\n<p><a href=\"https://github.com/jdleesmiller/docker-chat-demo/tree/04-the-app\">여기</a> 에서 지금까지의 코드를 받을 수 있다.</p>\n<h3>Docker for Dev and Prod</h3>\n<p>이제 우리는 개발 환경에서 도커 컴포즈를 이용해 앱을 실행할 수 있다.(멋지다.!) 이제 가능한 다음 단계에 대해 알아보자.</p>\n<p>만약 프로덕션의 우리의 애플리케이션 이미지를 배포하고자 한다면 위의 이미지에 어플리케이션 소스를 빌드하고 싶을 것이다. 이렇게 하기 위해선 <code class=\"language-text\">npm install</code>을 한 후에 단순히 어플리케이션 폴더를 컨테이너에 복사하게 된다. 물론 <code class=\"language-text\">npm install</code>은  <code class=\"language-text\">package.json</code>이나 <code class=\"language-text\">npm-shrinkwrap.json</code>이 변경되었을 때만 다시 실행하는 것이지 우리의 소스파일이 수정되었기 때문에 실행하는 것은 아니다. 또한 루트에 의한 카피문제는 여기서도 우회해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diff --git a/Dockerfile b/Dockerfile\nindex e2abdfc..68d0ad2 100644\n--- a/Dockerfile\n+++ b/Dockerfile\n@@ -12,4 +12,9 @@ USER app\n WORKDIR $HOME/chat\n RUN npm install\n\n+USER root\n+COPY . $HOME/chat\n+RUN chown -R app:app $HOME/*\n+USER app\n+\n CMD [&quot;node&quot;, &quot;index.js&quot;]</code></pre></div>\n<p>이제 호스트의 어떠한 불륨도 필요 없이 컨테이너를 단독으로 실행할 수 있게 되었다.  도커 컴포즈는 컴포즈 파일에서 코드의 중복을 피하기 위해 <a href=\"https://docs.docker.com/compose/extends/\">여러 컴포즈 파일을 구성</a> 할 수 있지만 이번 프로그램은 매우 단순하기 때문에 단순히 두 번째 컴포즈 파일, <code class=\"language-text\">docker-compose.prod.yml</code> 를 추가해 프로덕션 환경에서 응용 프로그램을 실행시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chat:\n  build: .\n  environment:\n    NODE_ENV: production\n  ports:\n    - &#39;3000:3000&#39;</code></pre></div>\n<p>아래와 같이 어플리케이션을 ‘production mode’로 실행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose -f docker-compose.prod.yml up\nRecreating dockerchatdemo_chat_1\nAttaching to dockerchatdemo_chat_1\nchat_1 | listening on *:3000</code></pre></div>\n<p>그리고 유사하게 컨테이너를 개발환경에 특화시킬 수 있다. 예를들면 소스 파일이 수정되면 자동적으로 컨테이너 안에서 다시 로드되도록 어플리케이션을 <a href=\"https://github.com/remy/nodemon\">노드몬</a> 에서 실행하는 것이다. (만약 도커 머신을 맥에서 사용한다면 아직 정상적으로 동작하지 않을 것이다. virtualbox의 쉐어드 폴더는 inotify로 동작하지 않기 때문이다. 빠른 시일내에 나아지길 바랄 뿐이다.) <code class=\"language-text\">npm install —save-dev nodemon</code>을 컨테이너에서 실행한 뒤 다시 빌드한다. 이제 개발횐경에서 더 적합 설정의 컨테이너에서 <code class=\"language-text\">node index.js</code> 디폴트 프로덕션 커맨드를 재정의 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diff --git a/docker-compose.yml b/docker-compose.yml\nindex e7bd11e..d031130 100644\n--- a/docker-compose.yml\n+++ b/docker-compose.yml\n@@ -1,5 +1,8 @@\n chat:\n   build: .\n+  command: node_modules/.bin/nodemon index.js\n+  environment:\n+    NODE_ENV: development\n   ports:\n     - &#39;3000:3000&#39;\n   volumes:</code></pre></div>\n<p>풀패스를 이용해 <code class=\"language-text\">nodemon</code>을 실행하는데 이는 NPM 디펜던시로 설치되어 있어 PATH 환경변수를 통해 접근할 수 없기 때문이다. NPM 스크립트를 이용해 <code class=\"language-text\">nodemon</code>을 실행할 수 있지만 이 방식은 문제점이 있다. NPM 스크립트로 실행하게 되면 NPM이 TERM시그널을  Docker에서 실제 프로세스로 전달하지 않아 종료까지 10초 정도가 걸리게 되는 경향이 있다.(기본적인 제한) 그래서 직접 명령을 실행하는 것이 나을 수 있다..(이 문제는  NPM 3.8.1 이상에서 수정된 것 같다. 이제 NPM스크립트를 컨테이너에서 사용할 수 있다.!)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose up\nRemoving dockerchatdemo_chat_1\nRecreating 3aec328ebc_dockerchatdemo_chat_1\nAttaching to dockerchatdemo_chat_1\nchat_1 | [nodemon] 1.9.1\nchat_1 | [nodemon] to restart at any time, enter `rs`\nchat_1 | [nodemon] watching: *.*\nchat_1 | [nodemon] starting `node index.js`\nchat_1 | listening on *:3000</code></pre></div>\n<p>특수화된 도커 컴포즈파일은 같은 <code class=\"language-text\">Dockerfile</code>과 이미지를 다수의 환경에 걸쳐 사용할 수 있게 한다.\n프로덕션에 개발 디펜던시를 설치하는 것이 공간 효율적으로 좋지는 않겠지만 내 생각엔 좋은 개발-프로덕션 환경을 위해 희생해야할 등가의 작은 희생이라고 생각한다. <a href=\"http://llis.nasa.gov/lesson/1196\">현명한 사람이 이야기했듯</a> ‘test as you fly, fly as you test.’ 지금 이 순간 우린 어떠한 테스트도 가지고 있지 않다. 하지만 원한다면 아래와 같이 쉽게 적용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose run --rm chat /bin/bash -c &#39;npm test&#39;\nnpm info it worked if it ends with ok\nnpm info using npm@3.7.5\nnpm info using node@v4.3.2\nnpm info lifecycle chat@1.0.0~pretest: chat@1.0.0\nnpm info lifecycle chat@1.0.0~test: chat@1.0.0\n\n&gt; chat@1.0.0 test /home/app/chat\n&gt; echo &quot;Error: no test specified&quot; &amp;&amp; exit 1\n\nError: no test specified\nnpm info lifecycle chat@1.0.0~test: Failed to exec test script\nnpm ERR! Test failed.  See above for more details.</code></pre></div>\n<p>(팁:  <code class=\"language-text\">npm —silent</code> 이렇게 실행하면 추가적인 아웃풋은 생략할 수 있다.)</p>\n<p><a href=\"https://github.com/jdleesmiller/docker-chat-demo\">여기</a> 지금까지의 코드가 있다.</p>\n<h3>결론</h3>\n<ul>\n<li>도커안에서 앱을 작성하고 개발환경과 프로덕션환경에서 완벽히 실행해 봤다. 오예!</li>\n<li>호스트에 아무것도 설치하지 않고 노드환경을 구성하기 위해 몇가지의 허들을 넘어야했지만 이것이 도움이 된다는 것을 알았으면 좋겠다. 그리고 이런 작업은 한번만 수행하면 된다.</li>\n<li>하위 폴더에 노드와 NPM의 디펜던시를 두는것은 루비의 bundler가 디펜던시를 다른곳에 설치하는 것에 비하면 조금 복잡할 수 있지만 <code class=\"language-text\">nested volume</code> 트릭으로 어느정도 쉽게 해결할 수 있었다.</li>\n<li>\n<p>여기서 다룬 것은 매우 간단한 어플리케이션이었지만 아래의 내용에 해당하는 추가 아티클들이 많이 있다.</p>\n<ul>\n<li>예를들어 API, Service Worker, 정적 프론테 엔드등 여려 서비스의 프로젝트를 구축한다. 하나의 큰 저장소가 서비스를 각각의 저장소로 분리하는 것보다 관리하기 쉬워보이지만 이것도 약간의 복잡성을 가지고 있다.</li>\n<li><code class=\"language-text\">npm link</code>를 사용하면 서비스들이 공유해 패키지안의 코드를 재사용할 수 있다.</li>\n<li>도커를 이용해 로그관리 툴이나 프로세스 모니터링 툴을 프로덕션에서 교체한다.</li>\n<li>데이터 마이그레이션을 포함해 상태나 구성을 관리한다.</li>\n</ul>\n</li>\n</ul>\n<p>여기까지 읽은 사람은 꼭 내 <a href=\"https://twitter.com/jdleesmiller\">twitter</a> 를 팔로우 해주면 고맙겠다.\n그리고 <a href=\"https://www.overleaf.com/\">Overleaf</a> 에서는 사람을 구하고 있다 :)</p>\n<p>드래프트 버전의 이 아티클을 리뷰해준 <a href=\"https://twitter.com/mmazour\">Michael Mzaour</a> 와 <a href=\"https://twitter.com/DrHammersley\">John Hammersley</a> 에게 감사를 표한다.</p>","fields":{"slug":"/2016-08-23-도커로 노드앱을 구축하며 배운것들/"},"excerpt":"도커로 노드 앱을 구축하며 배운것들 원문\nhttp://jdlm.info/articles/2016/03/06/lessons-building-node-app-docker.html\nby John Lees-Miller 도커를 이용해 노드제이에스 어플리케이션을 개발 하고 배포 하면서 어렵게 배운 팁과 트릭을 공유하고자 한다. 이 튜토리얼 아티클에서는 socket.io chat example을 이용해 기초부터 프로덕션에 응용 가능한 상태까지 될 수 있으면 쉽게 이해할 수 있도록 설명하려 한다. 아래와 같은 내용을 다룬다. 도커를 이용해 노드…","frontmatter":{"title":"도커로 노드앱을 구축하며 배운것들","date":"23 August, 2016","categories":"nodejs, tool, translation"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2019-05-22-크롬 네이티브 레이지 로딩/"},"frontmatter":{"title":"크롬 네이티브 레이지 로딩","categories":"frontend, tool","date":"22 May, 2019"},"excerpt":"레이지 로딩이란? 좋은 기회로 2019년 구글I/O에 참석했다. 웹 기술 세션 중에는 크게 눈에 띄는 세션은 없었지만, 일부 세션에서 소개된 웹과 관련 기술 몇 가지는 흥미로웠다. Native Lazy Loading, Portals, Duplex, Rich Results 정도가 나의 관심을 끌었다. 그중 키노트에서 시작해 몇 개의 세션에서 두루두루 언급한 네이티브 레이지 로딩이 제일 기대됐다. 관련 세션 레이지 로딩, 특히 이미지 레이지 로딩은 새로운 기술은 아니다. 기존 브라우저는 웹페이지를 불러올 때 초기부터 전체 영역에 해당…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-08-14-Vue.js에서의 다이나믹 컴포넌트 템플릿/"},"frontmatter":{"title":"Vue.js에서의 다이나믹 컴포넌트 템플릿","categories":"framework, translation","date":"14 August, 2018"},"excerpt":"원글: https://medium.com/scrumpy/dynamic-component-templates-with-vue-js-d9236ab183bb Vue.js에서의 다이나믹 컴포넌트 템플릿 컴포넌트들이 항상 같은 구조로 되어 있진 않다. 그리고 때론 관리해야할 상태들이 많을때도 있다. 이런 문제는 비동기적인 방법으로 해결할 수도 있다. 유즈 케이스 스크럼피는 알림, 댓글, 첨부 파일 등에서 컴포넌트 템플릿을 사용한다. 우선 댓글 부분을 살펴보면서 정확히 어떤 것을 말하는지 알아보자. 최근의 댓글은 더 이상 단순한 텍스트 필드가…"},{"fields":{"slug":"/2017-11-13-이맥스와 함께하는 개발환경/"},"frontmatter":{"title":"이맥스와 함께하는 개발환경","categories":"tool","date":"13 November, 2017"},"excerpt":"금단의 영역에 손을 대다 에디터, IDE뿐 아니라 업무에 관련된 새로운 도구가 나오면 꼭 써봐야 직성이 풀리는 성격이었지만 언젠가부터 그놈이 그놈이고 저놈이 그놈이고 새로운 기능이 있어도 개발을 할 때 사용하는 기능들은 매우 한정적이라는 사실을 깨닫게 되었다. 인텔리제이도 일년 이상은 사용해봤지만 프론트 엔드를 주로 개발하기에 딱히 IDE가 필요하지 않았고 수많은 기능들을 거의 사용하지 않다 보니 필요 이상의 도구를 사용하는 느낌이었다. 그런 느낌이 조금씩 자라나던 중 생뚱맞게도 박웅현 작가의 **여덟 단어** 라는 책을 읽다가 …"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodej","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들들은 글을 따로 안 쓰려고 하는 편인…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"},{"fields":{"slug":"/2020-09-07/"},"frontmatter":{"title":"하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세","categories":"productivity, motivation, life","date":"07 September, 2020"},"excerpt":"하루 24시간은 모두에게 공평하지만 그 24시간을 모두가 공평하게 사용하진 않는다. 하루의 여가시간을 어떻게 하면 더 효율적으로 사용할 수 있을까는 나의 오랜 고민거리였다. 단기 목표도 세워보고 장기 목표도 세워보고 포모도로, GTD도 도입하고 간츠도 사용해보고 하루 표준 계획표도 짜보고 일주일 보고서도 만들어봤다. 하루를 온전히 “노력”하기 위한 ”노력”을 많이 했다. 시도했던 것 대부분은 조금씩 달랐지만 주로 나에게 맞는 일상 패턴을 찾는 과정이었다. 개발자로서 회사 업무시간이나 여가 시간, 하루 대부분의 시간을 개발과 관련된…"}]}},"pageContext":{"slug":"/2016-08-23-도커로 노드앱을 구축하며 배운것들/","categoriesRegex":"/nodejs|tool|translation/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}