{"componentChunkName":"component---src-templates-post-tsx","path":"/2015-09-24-유닛테스트가-해야할-5가지-답변-테스트를-잘-작성하는-방법/","result":{"data":{"markdownRemark":{"html":"<h3>유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법</h3>\n<blockquote>\n<p>원문<br>\n<a href=\"https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d\">https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d</a></p>\n</blockquote>\n<br>\n<h2>대부분의 개발자들은 어떻게 테스트 해야하는지 모른다.</h2>\n<p>모든 개발자들을 프로덕션으로 디플로이할 때 발생할 수 있는 결함을 방지하기 위해 유닛 테스트를 해야 한다고 알고 있지만,\n대부분의 개발자들은 유닛 테스트의 필수적인 요소를 모른다.</p>\n<p>내가 보아온 유닛 테스트의 실패 사례는 셀 수가 없다.\n무엇이 잘못되는 건지 혹은 왜 이게 무슨 문제가 되는 것인지 뿐만 아니라 정확히 개발자가 무엇을 테스트하기 위한 것인지 조차 쉽게 알 수가 없었다.</p>\n<p>최근 프로젝트에서 테스트의 목적이 무엇인지에 대해 전혀 설명이 없는 거대한 양의 유닛 테스트를 만들어 내게 됐다.\n우린 훌륭한 팀이었기에 나는 경계를 늦추고 있었던 것이다. 그 결과 아직도 그 테스트를 작성한 사람만 이해할 수 있는 거대한 양의 유닛 테스트를 갖고 있다.</p>\n<p>다행히 우리는 전체적으로 API를 다시 설계했고 모든 테스트들을 버리고 바닥부터 다시 시작했다.\n그렇지 않았다면 테스트 코드를 다시 작성하는 일이 나의 최우선 과제였을 것이다.</p>\n<p>이 일이 당신에게도 일어나지 않도록 해야한다.</p>\n<br>\n<h2>왜 이런 테스트 규칙이 필요한걸까?</h2>\n<p>당신의 테스트는 소프트웨어의 결함을 방어하는 처음이자 최선의 라인이다.\n테스트는 linting이나 정적 분석보다도 더 중요하다. (정상적인 프로그램 로직에 아무런 문제가 없는 서브클래스의 오류들만 찾아낸다)\n테스트는 그 구현만큼 중요하다. (중요한 것은 코드는 요구 사항이 있고, 그것이 제대로 구현되어 있지 않다면 그것이 어떻게 구현되었는지는 중요하지가 않다.)</p>\n<p>유닛테스트는 어플리케이션을 성공으로 이끌 당신의 비밀무기가 될 많은 기능들을 가지고 있다.</p>\n<ol>\n<li><strong>디자인을 돕는다</strong>: 테스트를 작성한다는 것은 이상적인 API 디자인을 위한 명확한 시각을 제공한다.</li>\n<li><strong>기능을 문서화한다</strong>: 테스트 디스크립션은 그 코드에 모든 요구사항에 대한 구현을 표현하고 있다.</li>\n<li><strong>개발자의 이해를 테스트한다</strong>: 개발자가 모든 치명적인 구성요소의 요구사항들을 코드로 명확히 작성하기에 충분히 문제를 이해하고 있는가?</li>\n<li><strong>품질을 보증(QA)한다</strong>: 수동적인 QA는 오류를 범할 수 있다. 내 경험에 비춰보면 리팩토링을 하거나 새 기능 추가 혹은 제거할 때 여파가 있을 수 있는 모든 기능들을 기억해내서 테스트하는 것은 불가능하다.</li>\n<li><strong>지속적인 배포가 된다</strong>: 자동화된 QA는 프로덕션으로 배포되기 전에 잘못된 빌드가 배포 되는 것을 막아준다.</li>\n</ol>\n<h4>The Science of TDD</h4>\n<ul>\n<li>TDD는 버그의 발생 횟수를 줄여준다.</li>\n<li>TDD는 더욱 모듈화된 디자인이 되도록 도와준다.(소프트웨어이 민첩도와 팀의 속도를 개선해 준다.)</li>\n<li>TDD는 코드의 복잡도를 감소시켜 준다.</li>\n</ul>\n<p>TDD가 효과가 있다는 의미있고 경험적인 증거들은 충분히 있다.</p>\n<br>\n<h2>테스트를 먼저 작성해라.</h2>\n<p>Microsoft Research, IBM, Springer의 test-first와 test-after의 효율성에 대한 연구들에 의하면\n일관적으로 test-first가 테스트를 나중에 추가하는 것보다 더 좋은 결과를 가져온다고 한다.\n확실하게 말할 수 있다. 구현하기 전에\n테스트 먼저 작성해라.</p>\n<blockquote>\n<p>구현을 작성하기 전에 테스트를 먼저 작성해라.</p>\n</blockquote>\n<br>\n<h2>좋은 유닛테스트는 무엇인가?</h2>\n<p>자 TDD는 효과가 있다는게 입증되었다. 테스트를 먼저 작성하고 더 훈련하고, 이 과정을 믿는다. 알겠다.\n그러나 어떻게 좋은 테스트를 작성하는것인가?</p>\n<p>우리는 그 과정을 알아보기위해 실제 프로젝트의 간단한 예제를 살펴볼 것이다.\nStamp 구현의 'compose()' 펑션이다.</p>\n<p>그리고 테스트 프레임웍으로는 tape을 이용할 것이다 tape은 굉장히 명확하고 필수적인 기능들만 심플하게 가지고 있다.</p>\n<p>어떻게 좋은 유닛테스트를 작성할수 있는가에 대해 대답할 수 있기 전에, 먼저 어떻게 유닛테스트가 쓰이게 되는지 이해 할 필요가 있다.</p>\n<ul>\n<li><strong>디자인(API)을 돕는다</strong>: 구현보다 먼저 디자인 단계에 작성된다.</li>\n<li><strong>기능 문서화 및 개발자의 이해에 대한 테스트</strong>: 테스트는 테스트될 기능에 대한 명확한 설명이 제공되야 한다.</li>\n<li><strong>QA/지속적인 배포</strong>: 테스트는 배포 중에 에러시 배포를 중단시키고 좋은 버그 리포트를 제공한다.</li>\n</ul>\n<br>\n<h2>유닛 테스트를 버그 리포트로 활용</h2>\n<p>테스트가 실패하게되면 테스트 리포트는 어떤게 잘못되었는지 단서를 제공한다. 근본적인 원인을 빠르게 찾아내는 비밀은\n어디서 살펴보기 시작해야하는지를 아는 것이다. 그 과정은 명확한 버그리포트를 얻게된다면 훨씬 쉬워질 것이다.</p>\n<blockquote>\n<p>실패한 테스트는 고퀄리티의 버그 리포트가 될 수 있다.</p>\n</blockquote>\n<h4>좋은 테스트 실패 버그 리포트에는 무엇이 있는가.</h4>\n<ol>\n<li>무엇을 테스트 했는가?</li>\n<li>무슨 일을 하는가?</li>\n<li>아웃풋이 무엇인가? (혹은 실질적인 동작)</li>\n<li>아웃풋이 무엇이어야 했는가? (혹은 기대되는 동작)</li>\n</ol>\n<p>좋은 실패 리포트의 예\n<img src=\"https://cdn-images-1.medium.com/max/1400/1*jhYZ6dcMUKAhFyhsWJ6qGg.png\" alt=\"좋은 실패 리포트의 예\"></p>\n<h4>\"무엇을 테스트하는가?\"에 대한 대답으로 시작한다.</h4>\n<ul>\n<li>컴포넌트의 어떤 측면을 테스트하는가?</li>\n<li>기능은 어떤 일을 해야하는가? 어떤 특정한 요구사항을 테스트하는가?</li>\n</ul>\n<p>'compose()'함수는 다수의 스탬프(조합 가능한 팩터리 펑션)를 입력받아 새로운 스탬프를 만든다.\n이 테스트를 작성하기 위해서는 단일 테스트의 최종 목표(요구사항에 대한 테스트)에서부터 거꾸로 작업하게 될 것이다.\n이 테스트를 패스하기 위해 어떤 코드를 작성해야 할까?</p>\n<h4>기능이 어떤 일을 하는가?</h4>\n<p>나는 스트링을 작성하는 것으로 시작하는 것을 좋아한다. 어떤 펑션에도 전달되지 않고 아무 것에도 대입되지 않은 채로 말이다.  단지 명확하게 컴포넌트가 만족해야하는 특정한 요구사항에 집중한다. 지금의 경우는 'compose()' 펑션이 펑션을 리턴해야하는 사실로 부터 시작한다.</p>\n<p>단순하고 테스트 가능한 요구사항:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&#39;compose() should return a function&#39;</code></pre></div>\n<p>그리고 몇가지 부분을 스킵하고 테스트의 나머지 부분을 구체화한다. 이 스트링은 우리의 목표가 되어 미리 우리가 얻어 내야할것에 집중하게 해준다.</p>\n<h4>컴포넌트의 어떤 측면을 테스트 하는가?</h4>\n<p>\"컴포넌트 측면\"은 테스트별로 다양할것이고 이것은 컴포넌트를 테스트하는 적합한 커버리지에 따라 필요한 양이 결정될것이다.</p>\n<p>지금의 경우는 'compose()' 펑션의 리턴타입을 테스트해 제대로된것을 리턴하는지를 확인할것이고 반대로 아무것도 리턴을 안하거나 undefined를 리턴하는지를 확인할것이다.</p>\n<p>이 내용을 질문으로 바로 테스트 코드에 작성해보자. 대답은 테스트의 설명으로 들어간다. 이 단계에서 테스트를 위한 펑션을 실행하고 콜백을 넘겨 테스트러너가 테스트 할때 실행할수 있게한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;컴포넌트의 어떤 측면을 테스트하지?>'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>지금 우리는 compose 함수의 리턴값을 테스트한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Compose함수의 리턴 타입'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그리고 콜백안에서 첫번째 테스트의 설명이 들어가게된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Compose함수의 리턴 타입'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n     <span class=\"token string\">'compose()는 함수를 리턴한다'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<h2>아웃풋이 무엇인가?(예측한 아웃풋과 실제 아웃풋)</h2>\n<p>'equal()'은 내가 좋아하는 assertion이다. 만약에 'equal()'만이 모든 테스트에서 유일한 assertion이라면 거이 대부분의 이세상의 테스트는 더 나아질것이다. 왜냐면?</p>\n<p>'equal()'는 유닛테스트가 답변해야할 제일 중요한 2가지 질문에 답변하기 때문이다.</p>\n<ul>\n<li>실제 아웃풋이 무엇인가?</li>\n<li>아웃풋이 무엇이어야 했는가?</li>\n</ul>\n<p>만약 이 두가지 질문에 대답을 하지못한다면 제대로 테스트를 하지 못한것이다.\n다른것은 몰라도 이것한가지만은 꼭 기억하라</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> Equal은 당신의 새로운 기본 assertion이고 이것은 좋은 테스트의 열쇠가 될것이다.</code></pre></div>\n<p>강력한 기능을 가진 대부분의 assertion 라이브러리들의 다양한 assertion들은 테스트의 질을 떨어뜨린다.</p>\n<h4>도전</h4>\n<p>유닛테스트를 더 잘 작성하고 싶은가? 앞으로는 모든 테스트의 assertion 으로 'equal()'이나 'deepEqual()'을 사용해봐라 (아니면 당신 선택한 라이브러리중 가장 비슷한것) 테스트에 해가 되지 않을까 걱정하지 않아도 된다. 장담컨데 이런 연습이 극적으로 도움이 될것이다.</p>\n<p>코드에서는 어떻게 보일까?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;아웃풋이 무엇인가?>'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;아웃풋이 무엇이어야 했는가?>'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>테스트 실패시 첫번째 질문은 사실 두가지 의무를 가지고있다. 질문에 대답을 코드로 완성하는것으로 두번째에 대한 답변이 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;어떻게 테스트를 재현할까?>'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//how is the test reproduced?</span></code></pre></div>\n<p>여기서 중요한점은 'actual' 값이 어떤 컴포넌트의 public api에 의해 만들어진 값이라는것이다. 그렇지 않다면 이 테스트는 값어치가 없다. 나는 각종 목업과 스텁으로 도배되어 정작 테스트해야할 코드는 거쳐지지 않은 테스트들을 많이 봐왔다.</p>\n<p>리턴값을 확인해보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>assertion을 작성할때 'atucal' 이나 'expected'라는 로컬 변수를 꼭 사용하지 않아도 된다. 하지만 나는 최근에 나의 모든 테스트에 이런 로\n컬변수들을 사용하기 시작했다. 이런 로컬변수를 이용하면 테스트를 읽기 수훨해진다는것을 알아냈기때문이다.</p>\n<p>assertion이 얼마나 명확해지는지 확인해볼까?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>actual<span class=\"token punctuation\">,</span> expected<span class=\"token punctuation\">,</span> <span class=\"token string\">'compose() should return a funtion'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 하면 \"어떻게\"와 \"무엇\"을 테스트 코드에서 분리해 낼 수 있다.</p>\n<ul>\n<li>어떻게 결과를 얻어냈는지 알고 싶을 때는 변수 대입문을 살펴보면 된다.</li>\n<li>무엇을 테스트했는지를 알고싶을 때는 assertion의 설명을 보면 된다.</li>\n</ul>\n<p>이제 결과적으로 테스트 자체가 고퀄리티의 버그 리포트가 되었다.</p>\n<p>전체 테스트 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> test <span class=\"token keyword\">from</span> <span class=\"token string\">'tape'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> compose <span class=\"token keyword\">from</span> <span class=\"token string\">'../source/compose'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Compose function output type'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>actual<span class=\"token punctuation\">,</span> expected<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'compose() should return a function.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이제부터 테스트를 작성할 때는 테스트가 다음 질문에 모두 답변을 해야 한다는 것을 명심했으면 한다.</p>\n<ol>\n<li>무엇을 테스트하는가?</li>\n<li>테스트할 대상이 무엇을 해야 하는가?</li>\n<li>아웃풋이 무엇인가?</li>\n<li>아웃풋이 무엇이어야 했는가?</li>\n<li>어떻게 테스트가 재현될 수 있을까?(How can the test be reproduced?)</li>\n</ol>\n<p>마지막 질문에 대한 대답은 'actual' 값을 얻어오는 부분에서 확인할 수 있다.</p>\n<h4>유닛테스트 템플릿</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> test <span class=\"token keyword\">from</span> <span class=\"token string\">'tape'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// For each unit test you write,</span>\n<span class=\"token comment\">// answer these questions:</span>\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'What component aspect are you testing?'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">assert</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> actual <span class=\"token operator\">=</span> <span class=\"token string\">'What is the actual output?'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">'What is the expected output?'</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>actual<span class=\"token punctuation\">,</span> expected<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'What should the feature do?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  assert<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>유닛 테스트를 잘 사용하는 방법은 많이 있다. 하지만 테스트를 잘 작성하는 방법을 아는 것이 더 중요하다.</p>","fields":{"slug":"/2015-09-24-유닛테스트가 해야할 5가지 답변 테스트를 잘 작성하는 방법/"},"excerpt":"유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법 원문\nhttps://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d 대부분의 개발자들은 어떻게 테스트 해야하는지 모른다. 모든 개발자들을 프로덕션으로 디플로이할 때 발생할 수 있는 결함을 방지하기 위해 유닛 테스트를 해야 한다고 알고 있지만,\n대부분의 개발자들은 유닛 테스트의 필수적인 요소를 모른다. 내가 보아온 유닛 테스트의 실패 사례는 셀 수가 없다.\n무엇이 잘못되는 건지 혹은 왜 이게 무슨 …","frontmatter":{"title":"유닛테스트가 해야할 5가지 답변 - 테스트를 잘 작성하는 방법","date":"24 September, 2015","categories":"test, translation"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-06-15-유용한테스트케이스를위한개발자의자세/"},"frontmatter":{"title":"유용한 테스트 케이스를 위한 개발자의 자세","categories":"test, tdd","date":"15 June, 2020"},"excerpt":"각종 커뮤니티에 주기적으로 등장하는 \"private 메서드를 테스트하려면 어떻게 하나요?\" 혹은 \"private 메서드를 테스트해야 하나요?\" 와 같은 질문을 보면서 언젠가는 관련해서 정리해봐야겠다고 생각했었는데 꽤 시간이 흘러 이 내용으로 글을 써본다. 주제 자체는 간단한 편이지만 사람마다 생각이 다른 것 같다. 특히 해외 개발자들의 의견이 분분한 것 같다. 사실 이 문제는 효과적인 테스트 케이스(이하 TC)란 무엇인가란 질문과 비슷하다. private 메서드는 객체지향적인 관점에서 생각한 것이고 노출된 함수 내부에서 접근하는,…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-08-14-Vue.js에서의 다이나믹 컴포넌트 템플릿/"},"frontmatter":{"title":"Vue.js에서의 다이나믹 컴포넌트 템플릿","categories":"framework, translation","date":"14 August, 2018"},"excerpt":"원글: https://medium.com/scrumpy/dynamic-component-templates-with-vue-js-d9236ab183bb Vue.js에서의 다이나믹 컴포넌트 템플릿 컴포넌트들이 항상 같은 구조로 되어 있진 않다. 그리고 때론 관리해야할 상태들이 많을때도 있다. 이런 문제는 비동기적인 방법으로 해결할 수도 있다. 유즈 케이스 스크럼피는 알림, 댓글, 첨부 파일 등에서 컴포넌트 템플릿을 사용한다. 우선 댓글 부분을 살펴보면서 정확히 어떤 것을 말하는지 알아보자. 최근의 댓글은 더 이상 단순한 텍스트 필드가…"},{"fields":{"slug":"/2017-01-03-RxJS와 함께하는 함수형 리액티브 프로그래밍/"},"frontmatter":{"title":"RxJS와 함께하는 함수형 리액티브 프로그래밍","categories":"designpattern, javascript, translation","date":"03 January, 2017"},"excerpt":"원글: https://www.sitepoint.com/functional-reactive-programming-rxjs/ RxJS와 함께하는 함수형 반응형 프로그래밍 이 글은 Moritz Kröger, Bruno Mota와 Vildan Softic의 검수를 받았다. SitePoint의 컨텐트들이 최고가 될 수 있게 도와주는 SitePont의 모든 동료 리뷰어들에게 감사를 표한다. 본론으로 들어가기 전에 한가지 중요한 질문을 던져 본다. \"반응형 프로그래밍이란 무엇인가?\" 지금 시점에서 가장 일반적인 답변은 \"반응형 프로그래밍은 동…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2021-04-20/"},"frontmatter":{"title":"욕 안 먹는 개발자되기","categories":"developer","date":"20 April, 2021"},"excerpt":"직장인이라면 자연스럽게 업\u0018무를 대하는 태도가 캐릭터 처럼 만들어져요. 개발자도 마찬가지고요. 신입이라고 태도가 항상 나쁜 것도 아니고 경력이라고 항상 태도가 좋은 것도 아니에요. 코딩 스킬처럼 개선될 수도 있고요. 연차가 적을수록 몰라서 잘못된 태도를 갖는 경우가 많습니다. 이렇게 만들어진 태도는 보통 연차가 높을수록 개선되기 힘들다고들 하죠. 태도라는 큰 추상적인 덩어리는 억울하게도 한 부분, 한 사건에 의해 모든 것을 퉁쳐서 판단되기도 하죠. 이런 태도의 중요한 한 부분은 업무 중 문제가 발생했을 때에 뚜렷하게 나타난다고 생…"},{"fields":{"slug":"/2021-02-22/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 2","categories":"frontend, nodejs, tdd","date":"22 February, 2021"},"excerpt":"파트 1에서는 기본 자바스크립트 개발 환경을 러나와 함께 구축해봤어요. 기본 환경만으로 충분하신 분들도 계시겠지만 보통은 그렇지 않을 겁니다.\n이제 두 가지 개발 환경을 추가할 건데요. 타입 스크립트와 리액트 개발 환경이에요. 우선 타입스크립트 환경을부터 추가할 거예요. 그전에 러나로 해줘야 할 작업이 있습니다. 타입스크립트 환경도 결국 지금까지 저희가 구축한 자바스크립트 환경 위에 만들어질 것이기 때문에 디펜던시 모듈을 공유할 수 있도록 만들고 환경 설정 파일들도 기본 자바스크립트의 환경설정 파일들을 확장해서 사용할 거예요. 그…"},{"fields":{"slug":"/2021-02-15/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 1","categories":"frontend, nodejs, tdd","date":"15 February, 2021"},"excerpt":"개발을 하다 보면 특정 환경에서 빠르게 코드를 작성하고 그 결과를 확인해보고 싶을 때가 있어요. 라이브러리나 프레임웍 혹은 언어를 공부할 때나 아이디어를 빠르게 실험하거나 프로토타입 해보고 싶을 때 그렇지요. 바닐라 자바스크립트로 충분한 환경이라면 디렉터리 하나 만들고 js 파일 하나 html 파일 하나 만들어서 에디터를 열고 브라우저를 열어서 html 파일을 불러오는 것까지 하면 기본적인 준비가 끝나요. 근데요. 이런 바닐라 자바스크립트 환경을 만드는 것조차도 사실 귀찮을 때가 있어요. 이런 기본 환경도 귀찮은데 실무의 복잡한 …"},{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"}]}},"pageContext":{"slug":"/2015-09-24-유닛테스트가 해야할 5가지 답변 테스트를 잘 작성하는 방법/","categoriesRegex":"/test|translation/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}