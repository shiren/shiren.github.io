{"componentChunkName":"component---src-templates-post-tsx","path":"/2018-02-23-ECMAScript-스펙-톺아보기:-Primitive/","result":{"data":{"markdownRemark":{"html":"<p><img src=\"http://image.toast.com/aaaadh/real/2018/repimg/1.jpg\" alt=\"ECMAScript 스펙 톺아보기: Primitive\"></p>\n<h3>프리미티브에 대한 의문</h3>\n<p>현재 팀 내부에서는 시니어들이 팀 인력 채용 프로세스를 개선하고 있다. 프로세스 중에서도 현재는 필기시험 문제를 재출제하는 중인데 이게 생각보다 쉽지 않아 매일 매일 서로 의견이 분분하다. 그러던 어느 날 프리미티브에 대한 의견을 나누던 중 자바스크립트의 프리미티브를 객체 같이 사용된다고 설명해도 되느냐 안되느냐의 문제를 놓고 토론을 하게 되었는데 내 의견은 표면적으로 객체처럼 사용할 수 있기에 객체 같이 취급된다고 표현해도 된다는 의견이었고 다른 한 멤버는 중간에 프리미티브 래퍼가 관여하는 내용이기 때문에 그렇게 설명하면 안 된다는 것이었다. 한 명은 표면적인 결과에 다른 한 명은 내부의 동작에 집중했던 내용이었지만 토론의 과정에서 프리미티브를 너무 가볍게 이해하고 있는 게 아닌가 싶다는 생각이 들었다. 사실 개발 작업에는 큰 영향을 주지 않는 내용이겠지만 팀 업무 중에는 자바스크립트 사내교육도 있기 때문에 조금 더 깊고 정확한 이해가 있어야겠다고 생각했다. 그래서 스펙상의 정의와 실제 동작 방법에 대해서 자세히 알아보기로 했다.</p>\n<p>이 글에서는 프리미티브가 무엇이고 프리미티브 래퍼가 어떻게 관여하는지에 대한 내용을 스펙 문서와 몇 가지 실험을 토대로 다룬다. 원시라고 표기하려다가 사용되는 다른 용어들과의 이질감 때문에 그냥 프리미티브라고 표기하기로 했다. 이미 잘 알려진 내용을 다루기도 하지만 프리미티브에 대해 조금 더 자세히 알고 싶은 프런트 엔드 형, 누나를 위해 작성되었다. 일반적인 웹개발자라면 몰라도 되는 내용일 수 있다. 하지만 이야기할 때 <strong>굳이</strong> 명확하게 이야기하는 것을 좋아하는 사람이라면 짧은 글이니 읽도록 하자.</p>\n<h3>프리미티브 타입이란?</h3>\n<p>지겨운 이야기지만 짚고 넘어가자 자바스크립트에는 총 6개의 프리미티브 타입이 있다. undefined, null, boolean, string, number 그리고 마지막에 추가된 symbol이 있다. 여기에 프리미티브는 아니지만, object 타입만 더하면 ECMAScript에서 제공하는 언어 타입이 모두 정리된것이다.</p>\n<p>스펙 문서 개요에서는 프리미티브 값을 설명할 때 아래와 같이 기술했다.</p>\n<p>\"A primitive value is a member of one of the following built-in types: Undefined, Null, Boolean, Number, String, and Symbol …\"</p>\n<p>프리미티브 값은 내장 타입 중 한 종류에 속한다. 내장 타입 생성자하고는 별도의 개념이다. 아래와 같이 우리가 흔히 사용하고 있는 친구들이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> numberPrimitive <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> booleanPrimitive <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> stringPrimitivie <span class=\"token operator\">=</span> <span class=\"token string\">'string boy'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>typeof</h3>\n<p><code class=\"language-text\">typeof</code> 키워드를 이용하면 대상의 타입을 알 수 있다. 프리미티브 값에 직접 사용하면 해당 값의 타입을 알 수 있다. 함수는 실행 가능한 객체로 object 타입으로 분류된다. 그렇기 때문에 객체로서의 특성도 모두 가지고 있다. <code class=\"language-text\">typeof</code> 를 이용하면 ECMAScript 언어 타입을 구분할 수 있다. 특이점은 함수를 <code class=\"language-text\">typeof</code> 를 통해서 보면 \"function\" 으로 반환한다. ECMAScript 언어 타입에는 <code class=\"language-text\">function</code> 이라는 타입이 없는데도 말이다. typeof의 동작원리를 간단하게 설명하면 객체이면서 내부 프로퍼티 <code class=\"language-text\">[[Call]]</code> 이 구현되어 있다면 \"function\"을 반환한다. 함수에 대한 특별 대우인 것 같다. 함수와 객체를 구분해야 할 경우가 있으니 말이다. 여담이지만 <code class=\"language-text\">typeof null</code> 이 \"object\"를 리턴하는 점을 의아하게 생각할 수 있다. <code class=\"language-text\">null</code> 은 객체의 의도적인 부재(Intentional absence)를 뜻하는데 숫자 값이 없음을 뜻하는 0을 <code class=\"language-text\">typeof 0</code> 로 확인했을때 \"number\" 인점과 같은 맥락으로 객체가 없음을 뜻하는 <code class=\"language-text\">null</code> 도 \"object\"인것이다.</p>\n<h3>프리미티브의 특징</h3>\n<p>스펙에는 프리미티브에 직접적으로 연관된 단어가 총 세 개가 나온다.</p>\n<ul>\n<li>프리미티브 값(Primitive Value)</li>\n<li>프리미티브 타입(Primitive Type)</li>\n<li>프리미티브 객체(Primitive Object).</li>\n</ul>\n<p>프리미티브 값은 자바스크립트 언어 구현 중 가장 저수준의 데이텀을 뜻한다. 넘버 값의 경우 64-bit 배 정도의 바이너리 포맷 IEEE 754-2008 값이다. 그래서 소수점을 연산할때 IEEE754 표준의 <a href=\"https://www.google.co.kr/search?q=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90+%EC%98%A4%EB%A5%98\">잘 알려진 문제</a>가 발생하기도 한다.(0.1 + 0.2) 프리미티브 값은 특정 프리미티브 타입에 속한다. 프리미티브 타입은 해당 프리미티브 값으로 만들어질 수 있는 모든 것들을 뜻한다. 프리미티브 타입은 프로퍼티를 가질 수 없다. 객체가 아니기 때문이다. 프리미티브 객체는 해당 프리미티브 타입에 대응되는 내장된 생성자를 통해 만든 인스턴스다. 이 인스턴스는 특정 타입의 프리미티브 값을 다루는 프로퍼티들을 포함하고 있으며 내부 슬롯(<code class=\"language-text\">[[PrimitiveValue]]</code>)에 프리미티브 값을 들고 있는 객체로 객체 타입에 속한다. 즉 프로퍼티를 가질 수 있다. 객체타입이니까. 프리미티브 객체가 들고 있는 프리미티브 값은 <code class=\"language-text\">valueOf()</code> 메서드를 이용해 꺼내올 수 있다.</p>\n<p>예를 들면 숫자 10은 넘버 값(Number Value)이고 <code class=\"language-text\">number</code> 타입이 속한다. 그리고 <code class=\"language-text\">NaN</code> 과 <code class=\"language-text\">Infinity</code> 역시 <code class=\"language-text\">number</code> 타입에 속한다.(NaN과 Infinity는 IEEE754에 정의된 넘버 값이다.) <code class=\"language-text\">Number</code> 생성자를 통해 객체로 만들면 타입은 객체 타입이지만 <code class=\"language-text\">valueOf()</code> 를 통해 프리미티브 값을 구할 수 있다.</p>\n<p>연산자를 이용해 연산을 할 때는 객체의 <code class=\"language-text\">valueOf()</code> 메서드를 수행한 결과로 평가하기 때문에 객체든 프리미티브 값이던 서로 연산이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num10 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//넘버 값</span>\n<span class=\"token keyword\">typeof</span> num10 <span class=\"token comment\">// 'number', 넘버 값은 number 타입이다.</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token number\">NaN</span> <span class=\"token comment\">// 'number'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token number\">Infinity</span> <span class=\"token comment\">// 'number'</span>\n\n<span class=\"token keyword\">var</span> num10Obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 넘버 객체</span>\n<span class=\"token keyword\">typeof</span> num10Obj <span class=\"token comment\">// 'object'</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num10Obj<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 크롬 브라우저에서는 콘솔로 내부 슬롯 [[PrimitiveValue]] 의 값을 확인 할 수 있다.</span>\n\nnum10Obj<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 10</span>\n\nnum10 <span class=\"token operator\">===</span> num10Obj <span class=\"token comment\">// 실제로는 num10 === num10Obj.valueOf(); 로 평가</span></code></pre></div>\n<p><code class=\"language-text\">valueOf</code> 메서드는 오버라이드할 수 있다. 즉 내부 슬롯의 프리미티브 값을 반환하는게 아니라 객체의 의도에 맞게 다른 동작으로 변경 확장이 가능하다. 연산자 오버라이드를 할 수 없는 자바스크립트에서는 이점을 이용해 약소하나마 객체가 연산자에 적절히 반응하도록 개발할 수 있다. 이게 가능한 이유가 바로 내부적으로 객체의 <code class=\"language-text\">valueOf</code> 를 먼저 실행하고 그 결과 값으로 연산을 하기 때문이다.</p>\n<p>연산자의 연산시 객체의 <code class=\"language-text\">valueOf</code> 가 실행된다는 점을 이용하면 연산자 오버라이드를 할 수 없는 자바스크립트에서도 약소하나마 객체가 연산자에 의도한대로 반응하도록 개발할 수 있다. 즉 내부 슬롯의 프리미티브 값을 반환하는게 아니라 객체의 의도에 맞게 다른 동작으로 변경 확장이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">num10Obj<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">valueOf</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// valueOf 메서드는 오버라이드할 수 있다.</span>\n\nnum10 <span class=\"token operator\">+</span> num10Obj <span class=\"token comment\">// 60</span>\n\n<span class=\"token class-name\">Number</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>num10Obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10, 여전히 내부 슬롯에는 10이라는 값이 들어가 있다.</span></code></pre></div>\n<p>프리미티브 값은 이뮤터블하다. 그리고 프리미티브 타입은 Call by value이고 객체는 Call by reference 다. 하지만 객체 타입이라고 하더라도 <code class=\"language-text\">valueOf()</code> 메서드를 통해 프리미티브 값을 이용해 연산을 하므로 기본적으로 값의 이뮤터블함은 변함이 없다. 그리고 프리미티브 객체를 연산한 결과는 프리미티브 값으로 변경된다는 것에 주의해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> n10a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> n10b <span class=\"token operator\">=</span> n10a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 값이 복사되어 넘어간다.</span>\n\nn10b <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nn10a <span class=\"token operator\">===</span> n10b <span class=\"token comment\">// false,</span>\n\n<span class=\"token keyword\">var</span> no10a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> no10b <span class=\"token operator\">=</span> no10a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 참조가 전달된다., a와 b 둘다 같은 참조</span>\n<span class=\"token keyword\">var</span> no10c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nno10a <span class=\"token operator\">===</span> no10b <span class=\"token comment\">// true, 참조 비교를 한다.</span>\nno10a <span class=\"token operator\">===</span> no10c <span class=\"token comment\">// false, 참조 비교를 한다.</span>\n\nno10b <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nno10a <span class=\"token operator\">===</span> no10b <span class=\"token comment\">// false, num10Objb에는 이제 넘버 객체가 아닌 11이라는 넘버 값이 들어가 있다.</span></code></pre></div>\n<h3>프리미티브 객체로의 형 변환</h3>\n<p>프리미티브 값은 프로퍼티를 가질 수 없다. 애초에 객체도 아니고 그저 메모리상에 정해진 만큼의 공간을 차지하고 있는 저 수준의 데이터 조각일 뿐이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\nnum<span class=\"token punctuation\">.</span>newProp <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">.</span>newProp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span></code></pre></div>\n<p>코드 자체는 실행이 정상적으로 되고 에러는 발생하지 않지만 프로퍼티는 생성이 되지 않는다. 이렇게 동작하는 이유는 스펙 중 <code class=\"language-text\">Set</code> 추상 오퍼레이션의 동작 때문인데 <code class=\"language-text\">Set</code> 은 인자로 객체와 프로퍼티명 그리고 값등을 전달 받아 객체의 프로퍼티로 특정한 값을 할당할 때 사용한다. <code class=\"language-text\">Set</code> 추상 오퍼레이션은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Assert: Type(O) is Object.\n2. Assert: IsPropertyKey(P) is true.\n3. Assert: Type(Throw) is Boolean.\n4. Let success be ? O.[[Set]](P, V, O).\n5. If success is false and Throw is true, throw a TypeError exception.\n6. Return success.</code></pre></div>\n<p>오퍼레이션중 첫번째라인의 단언을 보면 대상의 타입이 <code class=\"language-text\">Object</code> 여야 한다. 즉 대상이 객체일때만 프로퍼티를 생성한다는 의미다. 객체가 아니라면 별도의 에러 없이 작업은 무시된다. 하지만 스트릭트 모드에서는 아래와 같이 <code class=\"language-text\">TypeError</code> 예외가 발생한다.</p>\n<p>\"Uncaught TypeError: Cannot create property 'newProp' on number '10'\"</p>\n<p>이렇게 스트릭트 모드에서 에러가 발생하는 내용은 스펙 중 <a href=\"http://www.ecma-international.org/ecma-262/8.0/index.html#sec-strict-mode-of-ecmascript\">The Strict Mode Of ECMAScript</a> 파트에서 찾아 볼수 있다.</p>\n<p>\"…nor to a non-existent property of an object whose <code class=\"language-text\">[[Extensible]]</code> internal slot has the value false. In these cases a TypeError exception is thrown.\"</p>\n<p>특정 식별자의 존재하지 않는 프로퍼티에 접근 시 대상의 <code class=\"language-text\">[[Extensible]]</code> 내부 슬롯이 <code class=\"language-text\">false</code> 값을 갖는 경우는 <code class=\"language-text\">TypeError</code> 예외를 발생하게 되는것이다. 다시 말하면 대상이 Extensible 하지 않으면 프로퍼티를 확장할 수 없으니 예외를 발생하는 것이다. 다행히 대상의 <code class=\"language-text\">[[Extensible]]</code> 내부 슬롯의 값을 확인하는 API가 자바스크립트 상에 노출되어 있어 코드에서 확인할 수 있다. 바로 <code class=\"language-text\">Object.isExtensible()</code> 메서드다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// false</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>자바스크립트의 프리미티브의 가장 대표적인 특징은 아마도 암묵적인 프리미티브 객체로의 형 변환일 것이다. 그래서 <code class=\"language-text\">Number</code> 생성자를 사용해서 만든 객체가 아닌 프리미티브 number 값도 <code class=\"language-text\">Number</code> 생성자의 프로퍼티들을 사용할 수 있다. 마치 객체 처럼 말이다. 코딩할때의 편의성을 고려했을때도 필요한 기능이긴 하지만 자바의 오토박싱에 영향을 받은것으로 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0.1234</span><span class=\"token punctuation\">;</span>\n\nnum<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0.12</span></code></pre></div>\n<p>간단한 함수를 <code class=\"language-text\">Number</code> 생성자의 프로토타입에 추가해서 형 변환이 실제로 일어나고 있는지 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token class-name\">Number</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">whoAmI</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">typeof</span> num<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"number\"</span>\n\nnum<span class=\"token punctuation\">.</span><span class=\"token function\">whoAmI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"object\"</span>\n<span class=\"token keyword\">typeof</span> num <span class=\"token comment\">// \"number\"</span></code></pre></div>\n<p>프리미티브 객체로의 형 변환은 추상 오퍼레이션 <code class=\"language-text\">[[ToObject]]</code> 에 의해 실질적으로 형 변환이 수행된다. 인자로 전달된 프리미티브 값의 타입에 따라 스펙의 변환 테이블을 토대로 정해진 생성자를 이용해 인자로 전달된 값을 내부 슬롯에 소유하고 있는 새로운 객체를 리턴한다. 다시 말하면 인자의 프리미티브 값과 동일하게 평가되는 프리미티브 객체를 반환한다. 형 변환이 일어나는 원인은 다양하지만 실제 형 변환은 <code class=\"language-text\">[[ToObject]]</code> 추상 오퍼레이션을 통해서만 변환된다.</p>\n<p>실질적으로 프리미티브 값을 프리미티브 객체로 변경하는 것은 <code class=\"language-text\">[[ToObject]]</code> 이고 우리가 사용하는 코드에서 프리미티브값의 프로퍼티에 접근을 수행할 때 실행되는 추상 오퍼레이션은 <code class=\"language-text\">[[GetV]]</code> 이다. <code class=\"language-text\">[[GetV]]</code> 는 프리미티브 값의 프로퍼티에 접근할 때 수행되는 오퍼레이션으로 대상이 객체가 아니면 동일한 타입의 프리미티브 객체를 생성해서 프로퍼티를 빌려 쓰게 해준다. 이 오퍼레이션에서도 물론 <code class=\"language-text\">[[ToObject]]</code> 를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Assert: IsPropertyKey(P) is true.\n2. Let O be ? ToObject(V).\n3. Return ? O.[[Get]](P, V).</code></pre></div>\n<p>P는 접근할 프로퍼티이고 V는 프리미티브 값 O는 새로 만들어질 프리미티브 객체이다. 접근할 프로퍼티의 키가 정상적인 키인지만 확인하고 <code class=\"language-text\">[[ToObject]]</code> 를 이용해 변환을 한 뒤 생성된 O에 <code class=\"language-text\">[[Get]]</code> 이라는 추상 오퍼레이션을 수행하는데 이 오퍼레이션은 객체의 프로퍼티에 접근할 때 수행되는 오퍼레이션이다. 프리미티브 값을 통해 객체를 만들었으니 정상적으로 객체의 프로퍼티에 접근하는것이다. 생각보다 단출한 작업이 아닐 수 없다. 프리미티브 객체로의 형 변환이라고 했지만 그건 표면적인 의미이고 실제로는 프리미티브 객체를 생성해서 사용한 뒤 제거하는 작업이다. 상단의 자바스크립트 코드에서 whoAmI란 메서드를 실행할때 생성된 객체는 whoAmI 메서드 실행이 종료되면 사라진다. 즉 기존의 프리미티브 값은 여전히 그냥 그대로 변화가 없다.</p>\n<h3>정리</h3>\n<p>이렇게 스펙을 토대로 프리미티브를 한번 정리해봤다. 앞으로 종종 스펙의 한 부분을 떼어서 정리해보는 내용으로 연재를 할까 한다. 확실히 정해진 건 아니지만 다음엔 스트릭트 모드에 관해 쓸 가능성이 크다. 뭐 스트릭트 모드도 뻔한 내용이지만 이미 뻔한 내용에 대해 더 자세히 알고자 시작한 일이다. 이 글은 최신 스펙을 기준으로 작성되었다. 예전에 ES5 스펙을 정독했었는데 요즘 최신 스펙들을 보며 참 많은 내용이 바뀌었고 바뀌고 있구나 하는 생각에 감회가 새롭다. 라고 생각이 들면서 앞으로 전체 정독은 하지 말아야지 하는 생각이…(?) 앞으로도 ECMAScript는 화이팅 넘치게 바뀌고 개선되고 발전할 예정이다.</p>","fields":{"slug":"/2018-02-23-ECMAScript 스펙 톺아보기: Primitive/"},"excerpt":"ECMAScript 스펙 톺아보기: Primitive 프리미티브에 대한 의문 현재 팀 내부에서는 시니어들이 팀 인력 채용 프로세스를 개선하고 있다. 프로세스 중에서도 현재는 필기시험 문제를 재출제하는 중인데 이게 생각보다 쉽지 않아 매일 매일 서로 의견이 분분하다. 그러던 어느 날 프리미티브에 대한 의견을 나누던 중 자바스크립트의 프리미티브를 객체 같이 사용된다고 설명해도 되느냐 안되느냐의 문제를 놓고 토론을 하게 되었는데 내 의견은 표면적으로 객체처럼 사용할 수 있기에 객체 같이 취급된다고 표현해도 된다는 의견이었고 다른 한 멤…","frontmatter":{"title":"ECMAScript 스펙 톺아보기: Primitive","date":"23 February, 2018","categories":"javascript"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-07-10-요즘 잘나가는 프론트엔드 개발환경 만들기(2018) ES6/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6","categories":"frontend, javascript","date":"10 July, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6 본 시리즈의  이전 아티클에서는 웹팩4에 대해 다루면서 바로 쓸 수 있는 환경을 만들어봤다. 이번편에는 그 환경 그대로 이용해 ES6 개발 환경을 추가한다. ES6는 이제 충분히 써도 될만한 시기라고 생각한다. \"나는 프런트 개발자가 아니기도 하고 브라우저가 모두 지원하지도 않기에 ES6는 아직 못쓴다\" 라고 생각하고 있다면 이 글을 통해 생각을 바꿀 수 있길 바란다. 어차피 쓰는 거 ES6뿐 아니라 ES8까지 사용하는 것을 권장한다. IE11 이하 버전들은 ES6나 이…"},{"fields":{"slug":"/2018-04-16-요즘 잘나가는 프론트엔드 개발 환경 만들기(2018) Webpack 4/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발 환경 만들기(2018): Webpack 4","categories":"frontend, javascript","date":"16 April, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발 환경 만들기(2018): Webpack 4 최근에 새로운 프로젝트를 진행하게 되면서 기존에 간만 살짝 보고 있던 뷰(Vue, 이하 뷰)를 본격적으로 도입하게 되었다. 사실 팀에서는 리액트를 선호하고 있었으나 회사 내부에서 뷰의 사용이 빠른 속도로 증가하고 있었고 그에 따라 팀내에서도 뷰에 대한 전문성이 필요하게 되었다. 뷰와 리액트는 서로 영향을 주고받고 발전해나가는 도구들이라 비슷한 부분이 많아 큰 어려움 없이 적응할 수 있었다. 새로운 프로젝트에서는 뷰를 사용하는것 뿐 아니라 다른 개발 환경도 요…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"},{"fields":{"slug":"/2020-09-07/"},"frontmatter":{"title":"하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세","categories":"productivity, motivation, life","date":"07 September, 2020"},"excerpt":"하루 24시간은 모두에게 공평하지만 그 24시간을 모두가 공평하게 사용하진 않는다. 하루의 여가시간을 어떻게 하면 더 효율적으로 사용할 수 있을까는 나의 오랜 고민거리였다. 단기 목표도 세워보고 장기 목표도 세워보고 포모도로, GTD도 도입하고 간츠도 사용해보고 하루 표준 계획표도 짜보고 일주일 보고서도 만들어봤다. 하루를 온전히 “노력”하기 위한 ”노력”을 많이 했다. 시도했던 것 대부분은 조금씩 달랐지만 주로 나에게 맞는 일상 패턴을 찾는 과정이었다. 개발자로서 회사 업무시간이나 여가 시간, 하루 대부분의 시간을 개발과 관련된…"},{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"}]}},"pageContext":{"slug":"/2018-02-23-ECMAScript 스펙 톺아보기: Primitive/","categoriesRegex":"/javascript/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}