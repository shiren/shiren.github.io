{"componentChunkName":"component---src-templates-post-tsx","path":"/2016-02-18-네이티브-애드온으로-Node.js의-성능을-향상-시키는-방법/","result":{"data":{"markdownRemark":{"html":"<h2>네이티브 애드온으로 Node.js의 성능을 향상 시키는 방법</h2>\n<blockquote>\n<p>원문<br>\n<a href=\"https://medium.com/developers-writing/how-to-get-a-performance-boost-using-node-js-native-addons-fd3a24719c85#.buw8o2rrn\">https://medium.com/developers-writing/how-to-get-a-performance-boost-using-node-js-native-addons-fd3a24719c85#.buw8o2rrn</a></p>\n</blockquote>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*T5rMwM8edXuILUrew2YHxw.jpeg\" alt=\"이상한그림\"></p>\n<p>아마도 천 번 정도는 들어봤을 법한 Node.js(이하 노드)의 네이티브 모듈에 대해 그것이 무엇이고 왜 고려되어야 할지 다뤄본다.</p>\n<blockquote>\n<p>노드 애드온은 C나 C++로 작성된 동적 링크 공유 객체로 노드의 <code class=\"language-text\">require()</code> 함수에 의해 로드 되어 일반적인 노드 모듈처럼 사용된다.</p>\n</blockquote>\n<p>좋아 보이는데 왜 이미 익숙한 자바스크립트를 놔두고 대학시절에나 봤었던 C++로 코드를 작성해야 할까? 대답은 오직 하나 <em>퍼포먼스</em> 때문이다.</p>\n<h3>예제</h3>\n<p>온라인 회문(palindrome, 역: 앞으로 읽으나 뒤로 읽으나 똑같은 aba, abba 이런류의 문자열) 계산 도구를 만든다고 가정해보자. 자바스크립트는 고급 언어이기 때문에 빠르고 깔끔하게 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> str <span class=\"token operator\">===</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>끝났다. 이제 코드를 프로덕션에 디플로이하고 잠이나 자러 가면 된다.\n하지만, 시간이 흐른뒤에 위 알고리즘은 보기만큼 좋지 않고 실제로 엄청 느리다는 것을 깨닫게 된다.\n그리곤 다른 방법을 찾아 해매게 된다.</p>\n<h3>노드 애드온 생태계</h3>\n<p>애드온을 만들기 위해서는 아래의 툴들이 필요하다.</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node-gyp\">node-gyp</a>: 네이티브 애드온을 컴파일 하기 위한 크로스 플랫폼 cli</li>\n<li><a href=\"https://github.com/TooTallNate/node-bindings\">node-bindings</a>: 작성한 네이티브 애드온 .node 파일을 불러오기 위한 헬퍼 모듈</li>\n<li><a href=\"https://github.com/nodejs/nan\">nan</a>: 노드버전별 애드온 개발을 쉽게 하기 위한 도구</li>\n</ul>\n<p>아래의 명령으로 한번에 모두 설치할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm i node-gyp -g &amp;&amp; npm i node-bindings nan --save</code></pre></div>\n<p>이후 <code class=\"language-text\">&quot;gypfile&quot;: true</code> 옵션을 package파일에 추가하고 <em>binding.gyp</em> 파일을 만든다.</p>\n<p><em>binding.gyp</em></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n “targets”: [\n   {\n     “target_name”: “palindrome”,\n     “sources”: [ “palindrome.cc” ],\n     “include_dirs”: [ “&lt;!(node -e \\”require(‘nan’)\\”)” ]\n   }\n ]\n}</code></pre></div>\n<p>이제 C++로 palindrome 메소드를 작성하기 위한 준비가 끝났다. 아래의 코드를 살펴 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;nan.h&gt;\n\nusing namespace v8;\n\nvoid IsPalindrome(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n  String::Utf8Value sentence(info[0]-&gt;ToString());\n  std::string str = std::string(*sentence);\n  int len = str.length();\n  int half = len / 2;\n  int start = 0;\n  int end = len - 1;\n  int space = 32;\n  bool isPal = true;\n\n  while (half &gt; 0 &amp;&amp; isPal) {\n    bool startSpace = str.at(start) == space;\n    bool endSpace = str.at(end) == space;\n\n    if (str.at(start) == str.at(end)) {\n      start++;\n      end--;\n    } else if (startSpace || endSpace) {\n      startSpace &amp;&amp; start++;\n      endSpace &amp;&amp; end--;\n    } else {\n      isPal = false;\n    }\n\n    half--;\n  }\n\n  info.GetReturnValue().Set(isPal);\n}\n\nvoid Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n  NODE_SET_METHOD(module, &quot;exports&quot;, IsPalindrome);\n}\n\nNODE_MODULE(addon, Init);</code></pre></div>\n<p>아마 최상의 구현은 아닐지 모른다. 하지만 <em>O(n)</em>의 시간 복잡도를 가지고 있어 지금으론 충분하다. 이제 코드를 확인해보자. 우선 아래의 코드부터 시작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n   NODE_SET_METHOD(module, “exports”, IsPalindrome);\n}\n\nNODE_MODULE(addon, Init);</code></pre></div>\n<p>위 코드는 추후 노드에서 사용될 수 있도록 노출해준다. <a href=\"https://github.com/nodejs/node/blob/master/src/node.h#L457\">NODE_MODULE</a>과 <a href=\"https://github.com/nodejs/node/blob/master/src/node.h#L244-L255\">NODE<em>SET</em>METHOD</a> 메소드의 소스코드는 한 번 살펴보도록 하자.\n다음으로 확인해야 할 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">void IsPalindrome(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n  String::Utf8Value sentence(info[0]-&gt;ToString());\n  std::string str = std::string(*sentence);</code></pre></div>\n<p>여기서 우린 v8의 클래스를 사용하게 된다. <em>FunctionCallbackInfo</em>는 호출하는 컨텍스트에 대한 정보에 접근할 수 있게 해 주는데, 리시버 그리고 인자들의 개수와 값, 함수의 홀더에 대한 정보를 포함한다.\n마침내 <em>Utf8Value</em> 클래스를 사용해 인자를 <em>std string</em>으로 변환하게 되고 이것들이 우리의 알고리즘 안에서 사용될 것이다.\n두 가지의 구현의 퍼포먼스를 측정하기 위해서 <a href=\"https://benchmarkjs.com/\">benchmarkjs</a>를 사용하는데 jsperf.com 내부에서 사용하는 라이브러리이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm i --save benchmark</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">var Benchmark = require(&#39;benchmark&#39;);\nvar palindromeC = require(&#39;bindings&#39;)(&#39;palindrome.node&#39;);\nvar palindromeJs = require(&#39;./palindrome.js&#39;);\nvar suite = new Benchmark.Suite;\nvar str = &#39;a man a plan a cat a ham a yak a yam a hat a canal panama&#39;;\n\nsuite\n.add(&#39;Javascript palindrome&#39;, function() {\n  palindromeJs(str);\n})\n.add(&#39;C palindrome&#39;, function() {\n  palindromeC(str);\n})\n.on(&#39;cycle&#39;, cycle)\n.on(&#39;complete&#39;, complete)\n.run({ &#39;async&#39;: true });\n\nfunction cycle(event) {\n  console.log(String(event.target));\n}\n\nfunction complete(a,b) {\n  console.log(&#39;Fastest: &#39; + this.filter(&#39;fastest&#39;).map(&#39;name&#39;));\n  console.log(&#39;Slowest: &#39; + this.filter(&#39;slowest&#39;).map(&#39;name&#39;));\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C palindrome x 1,353,176 ops/sec ±1.98% (80 runs sampled)\nJavascript palindrome x 293,383 ops/sec ±1.34% (87 runs sampled)\n\nFastest: C palindrome\nSlowest: Javascript palindrome</code></pre></div>\n<p>C palindrome이 자바스크립트 구현보다 460% 빠르다.\n미친 성능 향상이 아닌가? 하지만 여기엔 한가지 놓친 부분이 있다. 비교된 코드의 구현이 다르다. 자바스크립트의 구현이 C++의 구현보다 조금 더 비용이 비싼 구현이다.\nC++과 정확하게 같은 구현으로 자바스크립트 코드를 다시 만들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> half <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span>length <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> end <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> palindrome <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> <span class=\"token constant\">SPACE</span> <span class=\"token operator\">=</span> <span class=\"token number\">32</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> <span class=\"token constant\">COMMA</span> <span class=\"token operator\">=</span> <span class=\"token number\">44</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> startSpace<span class=\"token punctuation\">,</span> endSpace<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>half <span class=\"token operator\">&amp;&amp;</span> palindrome<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    startSpace <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token constant\">SPACE</span> <span class=\"token operator\">||</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token constant\">COMMA</span><span class=\"token punctuation\">;</span>\n    endSpace <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token constant\">SPACE</span> <span class=\"token operator\">||</span>  str<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token constant\">COMMA</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> str<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      start<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n      end<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>startSpace <span class=\"token operator\">||</span> endSpace<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      startSpace <span class=\"token operator\">&amp;&amp;</span> start<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n      endSpace <span class=\"token operator\">&amp;&amp;</span> end<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      palindrome <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    half<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> palindrome<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C palindrome x 1,370,148 ops/sec ±1.32% (80 runs sampled)\nJavascript palindrome x 3,326,042 ops/sec ±0.98% (82 runs sampled)\n\nFastest: Javascript palindrome\nSlowest: C palindrome</code></pre></div>\n<p>놀랍게도 이제는 오히려 자바스크립트 구현이 240% 더 빨라졌다. 이게 말이 되나?\n다행스럽게도 이를 해결할 방법이 있다.</p>\n<h3>nan 소개</h3>\n<blockquote>\n<p>노드의 네이티브 추상화</p>\n<p>V8(그리고 약간의 노드코어)의 미친듯한 변경 사항 때문에 네이티브 애드온을 버전별로 컴파일을 해야한다.\nnan의 목적은 매번 NODE<em>MODULE</em>VERSION을 따로 조회하지 않고 네이티브 노드 애드온에는 필요한 로직만 담아 개발하게 하는 것이다.</p>\n</blockquote>\n<p>우리의 네이티브 구현이 자바스크립트의 구현보다 느렸던 이유는 바로 아래의 코드 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">String::Utf8Value sentence(info[0]-&gt;ToString());\nstd::string str = std::string(*sentence);</code></pre></div>\n<p>여기서는 첫번째 인자를 <em>std string</em>으로 캐스팅하는것 외엔 아무것도 하지 않는다.\n하지만 <em>Utf8Value</em>의 특별한 내부 동작 때문에 이 변경의 비용이 높아지게 된다.\n자 이제 nan을 이용하면 어떻게 되는지 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">Nan::Utf8String arg0(info[0]);\nchar *str = *arg0;</code></pre></div>\n<p>이제 v8의 Utf8Value대신 <em>nan의 Uft8String</em>을 사용하고 이후에 char의 array로 캐스팅할 것이다.\n그외 char array와 동작하도록 코드의 몇몇 작은 부분을 수정했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;nan.h&gt;\n\nusing namespace v8;\n\nvoid IsPalindrome(const FunctionCallbackInfo&lt;Value&gt;&amp; info) {\n  Nan::Utf8String arg0(info[0]);\n  char *str = *arg0;\n  size_t len = arg0.length();\n  int half = len / 2;\n  int start = 0;\n  int end = len - 1;\n  int space = 32;\n  int comma = 44;\n  bool isPal = true;\n  bool startSpace;\n  bool endSpace;\n\n  while (half &gt; 0 &amp;&amp; isPal) {\n    startSpace = str[start] == space || str[start] == comma;\n    endSpace = str[end] == space || str[end] == comma;\n\n    if (str[start] == str[end]) {\n      start++;\n      end--;\n    } else if (startSpace || endSpace) {\n      startSpace &amp;&amp; start++;\n      endSpace &amp;&amp; end--;\n    } else {\n      isPal = false;\n    }\n\n    half--;\n  }\n\n  info.GetReturnValue().Set(isPal);\n}\n\nvoid Init(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) {\n  NODE_SET_METHOD(module, &quot;exports&quot;, IsPalindrome);\n}\n\nNODE_MODULE(addon, Init);</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C palindrome x 5,753,415 ops/sec ±1.40% (84 runs sampled)\nJavascript palindrome x 3,307,899 ops/sec ±1.28% (84 runs sampled)\n\nFastest: C palindrome\nSlowest: Javascript palindrome</code></pre></div>\n<p>이제 자바스크립트보다 C++이 170% 나아졌다. thanks to nan :)</p>\n<h3>가장 큰 회문(palindrome)</h3>\n<p>이제 큰 문자열에서도 성능의 향상되었는지 아니면 달라진 게 없는지를 체크해 볼 수 있도록 가장 큰 회문으로 테스트를 해보자.\n(17,826 Word Palindrome)[http://norvig.com/pal17txt.html]으로 테스트를 해본뒤의 결과는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C palindrome x 4,636 ops/sec ±1.10% (83 runs sampled)\nJavascript palindrome x 1,712 ops/sec ±1.22% (83 runs sampled)\n\nFastest: C palindrome\nSlowest: Javascript palindrome</code></pre></div>\n<p>또다시 C++이 더 나은 퍼포먼스를 보여줬고 이번엔 270% 정도이다. 아마도 그 정도는 아닐지 몰라도 큰 문자열에서 얼마나 나아졌는지를 알 수가 있다.</p>\n<h3>결론</h3>\n<p>지금까지 노드 네이티브 애드온을 만드는 방법과 어떻게 벤치마크하는지를 알아봤다. 어쩌면 위의 예제들은 단지 스트링과의 작업만을 다루기 때문에 충분한 퍼포먼스의 향상을 얻지 못했을지도 모른다.\n하지만 적어도 결과를 보여줬고 어떻게 하는지의 예제도 볼 수 있었다.</p>\n<p>plaindrome 애드온의 모든 코드는 <a href=\"https://github.com/zzarcon/palindrome\">여기</a>에서 확인 가능하고 사용된 벤치마크 예제는 <a href=\"https://github.com/zzarcon/node-palindrome-benchmark\">여기</a>에서 확인할 수 있다.</p>\n<p>마지막으로 노드 애드온에 대한 예제나 적절한 문서를 찾는 것은 정말 어려웠다는 점을 밝히고 싶다. 아래에 내가 학습하면서 참고한 자료들을 공유한다.</p>\n<ul>\n<li><a href=\"https://nodejs.org/api/addons.html\">Node.js official guide</a></li>\n<li><a href=\"https://developers.google.com/v8/get_started\">v8 getting started</a></li>\n<li><a href=\"https://github.com/nodejs/node-addon-examples\">Addon examples</a></li>\n<li><a href=\"https://v8docs.nodesource.com/\">v8 documentation</a></li>\n<li><a href=\"https://blog.scottfrees.com/\">Scott Frees blog</a></li>\n<li><a href=\"http://www.slideshare.net/cb1kenobi/nodejsiojs-native-c-addons\">Node Native addons slides by Chris Barber</a></li>\n<li><a href=\"https://github.com/nodejs/node-gyp/wiki/%22binding.gyp%22-files-out-in-the-wild\">Community addons</a></li>\n</ul>","fields":{"slug":"/2016-02-18-네이티브 애드온으로 Node.js의 성능을 향상 시키는 방법/"},"excerpt":"네이티브 애드온으로 Node.js의 성능을 향상 시키는 방법 원문\nhttps://medium.com/developers-writing/how-to-get-a-performance-boost-using-node-js-native-addons-fd3a24719c85#.buw8o2rrn 이상한그림 아마도 천 번 정도는 들어봤을 법한 Node.js(이하 노드)의 네이티브 모듈에 대해 그것이 무엇이고 왜 고려되어야 할지 다뤄본다. 노드 애드온은 C나 C++로 작성된 동적 링크 공유 객체로 노드의  함수에 의해 로드 되어 일반적인 노드 모듈…","frontmatter":{"title":"네이티브 애드온으로 Node.js의 성능을 향상 시키는 방법","date":"18 February, 2016","categories":"nodejs, javascript, translation"}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-03-12-은닉을 향한 자바스크립트의 여정/"},"frontmatter":{"title":"은닉을 향한 자바스크립트의 여정","categories":"javascript","date":"12 March, 2020"},"excerpt":"ECMAScript 클래스 필드(class field) 명세중에  즉  (이하 Private 속성) 가 있다. 클래스 필드 스펙은 Stage 3(Candidate)까지 올랐으니 아마 곧 Stage 4(Finished)를 거쳐 표준 스펙이 될 것이다. 사실 초기에 명세 문서를 봤을 때는 \"드디어 private이 생기는건가?\"하는 기대감과 \"문법이 좀 별론데\"라는 실망감이 있었을 뿐 뭔가 현실감은 없었다. 그렇게 시간이 흘러 기억 속에서 잊힌 채로 지내다가 얼마전에 타입스크립트 3.8에서 정식으로 지원한다는 소식을 들었고 이를 계기로…"},{"fields":{"slug":"/2018-10-24-reduce()를 이용해 순차적으로 프로미스를 해결하는 방법/"},"frontmatter":{"title":"reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법","categories":"javascript, translation","date":"24 October, 2018"},"excerpt":"원글: Why Using reduce() to Sequentially Resolve Promises Works https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/ reduce() 를 이용해 순차적으로 프라미스를 해결하는 방법  객체를 사용하지 않고 비동기 자바스크립트 코드를 작성하는 것은 눈을 감고 케이크를 굽는 것 만큼 어렵다. 물론 할 수 있지만 복잡해질 것이고 결국 화딱지가 나서 못 해먹을 것이다. 꼭 필요하다고 말할 순 없지만 일단 …"},{"fields":{"slug":"/2018-07-10-요즘 잘나가는 프론트엔드 개발환경 만들기(2018) ES6/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6","categories":"frontend, javascript","date":"10 July, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발환경 만들기(2018): ES6 본 시리즈의  이전 아티클에서는 웹팩4에 대해 다루면서 바로 쓸 수 있는 환경을 만들어봤다. 이번편에는 그 환경 그대로 이용해 ES6 개발 환경을 추가한다. ES6는 이제 충분히 써도 될만한 시기라고 생각한다. \"나는 프런트 개발자가 아니기도 하고 브라우저가 모두 지원하지도 않기에 ES6는 아직 못쓴다\" 라고 생각하고 있다면 이 글을 통해 생각을 바꿀 수 있길 바란다. 어차피 쓰는 거 ES6뿐 아니라 ES8까지 사용하는 것을 권장한다. IE11 이하 버전들은 ES6나 이…"},{"fields":{"slug":"/2018-04-16-요즘 잘나가는 프론트엔드 개발 환경 만들기(2018) Webpack 4/"},"frontmatter":{"title":"요즘 잘나가는 프론트엔드 개발 환경 만들기(2018): Webpack 4","categories":"frontend, javascript","date":"16 April, 2018"},"excerpt":"요즘 잘나가는 프론트엔드 개발 환경 만들기(2018): Webpack 4 최근에 새로운 프로젝트를 진행하게 되면서 기존에 간만 살짝 보고 있던 뷰(Vue, 이하 뷰)를 본격적으로 도입하게 되었다. 사실 팀에서는 리액트를 선호하고 있었으나 회사 내부에서 뷰의 사용이 빠른 속도로 증가하고 있었고 그에 따라 팀내에서도 뷰에 대한 전문성이 필요하게 되었다. 뷰와 리액트는 서로 영향을 주고받고 발전해나가는 도구들이라 비슷한 부분이 많아 큰 어려움 없이 적응할 수 있었다. 새로운 프로젝트에서는 뷰를 사용하는것 뿐 아니라 다른 개발 환경도 요…"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"1 독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한…"},{"fields":{"slug":"/2020-09-07/"},"frontmatter":{"title":"하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세","categories":"productivity, motivation, life","date":"07 September, 2020"},"excerpt":"하루 24시간은 모두에게 공평하지만 그 24시간을 모두가 공평하게 사용하진 않는다. 하루의 여가시간을 어떻게 하면 더 효율적으로 사용할 수 있을까는 나의 오랜 고민거리였다. 단기 목표도 세워보고 장기 목표도 세워보고 포모도로, GTD도 도입하고 간츠도 사용해보고 하루 표준 계획표도 짜보고 일주일 보고서도 만들어봤다. 하루를 온전히 “노력”하기 위한 ”노력”을 많이 했다. 시도했던 것 대부분은 조금씩 달랐지만 주로 나에게 맞는 일상 패턴을 찾는 과정이었다. 개발자로서 회사 업무시간이나 여가 시간, 하루 대부분의 시간을 개발과 관련된…"},{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2020-06-15-유용한테스트케이스를위한개발자의자세/"},"frontmatter":{"title":"유용한 테스트 케이스를 위한 개발자의 자세","categories":"test, tdd","date":"15 June, 2020"},"excerpt":"각종 커뮤니티에 주기적으로 등장하는 \"private 메서드를 테스트하려면 어떻게 하나요?\" 혹은 \"private 메서드를 테스트해야 하나요?\" 와 같은 질문을 보면서 언젠가는 관련해서 정리해봐야겠다고 생각했었는데 꽤 시간이 흘러 이 내용으로 글을 써본다. 주제 자체는 간단한 편이지만 사람마다 생각이 다른 것 같다. 특히 해외 개발자들의 의견이 분분한 것 같다. 사실 이 문제는 효과적인 테스트 케이스(이하 TC)란 무엇인가란 질문과 비슷하다. private 메서드는 객체지향적인 관점에서 생각한 것이고 노출된 함수 내부에서 접근하는,…"}]}},"pageContext":{"slug":"/2016-02-18-네이티브 애드온으로 Node.js의 성능을 향상 시키는 방법/","categoriesRegex":"/nodejs|javascript|translation/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}