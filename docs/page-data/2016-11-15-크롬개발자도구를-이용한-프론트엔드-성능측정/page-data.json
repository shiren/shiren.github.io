{"componentChunkName":"component---src-templates-post-tsx","path":"/2016-11-15-크롬개발자도구를-이용한-프론트엔드-성능측정/","result":{"data":{"markdownRemark":{"html":"<h2>크롬 개발자 도구를 이용한 프론트엔드 성능 측정</h2>\n<h3>타임라인</h3>\n<p>타임라인은 웹페이지를 로드할때나 혹은 유저 인터렉션 등으로 인해 브라우저에서 발생하는 동작들을 레코딩하고 타임라인 형태로 시각화해주는 도구다. 시간의 흐름에 따라 브라우저의 이벤트(여기서의 이벤트는 DOM상의 이벤트가 아닌 브라우저 내부의 동작, 물론 DOM이벤트를 발생시키는 이벤트도 있다)뿐 아니라 CPU, 메모리, 네트워크 사용량과 FPS까지 확인 가능하다. 이벤트에 스택 트레이스 형태로 자바스크립트의 함수 콜 스택도 확인이 가능해 어떤 자바스크립트 코드가 성능에 영향을 주고 있는지도 쉽게 확인할 수 있다. 두가지의 성능 측정 예를 통해 타임라인의 기능을 살펴본다.</p>\n<h3>innerHTML 성능 측정</h3>\n<p>innerHTML은 웹개발자라면 자주 접했을 DOM 엘리먼트 속성이다. 이 속성을 통해 특정 엘리먼트의 하위 엘리먼트들을 HTML 텍스트로 생성하거나 변경할 수 있는데 사용하기에 따라 최악의 성능을 보여준다. innerHTML속성에 대한 브라우저의 동작방식 때문인데 innerHTML의 값이 어떤 방식으로든 직접 변경되면 기존 하위 엘리먼트를 모두 삭제하고 다시 innerHTML의 내용을 기준으로 HTML을 파싱하고 엘리먼트들을 생성한다. 이런 동작 방식은 아래와 같은 코드에서 심각한 퍼포먼스를 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">+=</span> <span class=\"token string\">'&lt;div>~Pen Pineapple Apple Pen~&lt;/div>'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>innerHTML에 텍스트 어펜드로 HTML 텍스트를 적용하면 기존에 해당 엘리먼트의 자식으로 속해 있던 이미 만들어진 엘리먼트들도 새로 추가된 텍스트와 함께 다시 파싱되고 만들어지기 때문에 루프를 돌고 난 후 보여지는 div 태그의 갯수는 1,000개이지만 실제로 브라우저가 파싱해서 만들거나 지우게 된 div태그는 500,500개이다. 그래서 루프를 돌수록 파싱하는 양도 많아져 점점 수행하는 시간이 길어진다. 매번 파싱하는 비용도 그렇지만 점점 파싱하는데 걸리는 시간도 길어지니 최악의 퍼포먼스를 보여준다. 해결 방법은 여러가지가 있지만 여기서는 innerHTML을 이용해서 해결하는 방법으로 비교해보겠다. 해결방법은 HTML 텍스트를 미리 만들어둔 다음 한번에 innerHTML에 적용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> str <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    str <span class=\"token operator\">+=</span> <span class=\"token string\">'&lt;div>~Pen Pineapple Apple Pen~&lt;/div>'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\ndocument<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> str<span class=\"token punctuation\">;</span></code></pre></div>\n<p>코드를 실행해보면 육안으로도 두 번째 구현이 훨씬 빠른것을 확인할 수 있다. 이제 위 두 가지의 구현이 타임라인에서는 어떤 차이를 보여주는지 확인해보자. 우선 타임라인의 기본 사용법을 알아보자.</p>\n<h3>타임라인 기본 사용법</h3>\n<p>타임라인의 기본적인 작동 방법은 레코딩 버튼을 눌러 레코딩을 시작하고 측정하고자 하는 동작을 수행하고 레코딩을 종료한 뒤 측정된 결과를 확인하는 것이다. 레코딩시 추가로 기록할 정보들을 선택할 수도 있는데 상단의 컨트롤 바의 체크박스를 통해서 할 수 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20128126/4db6f9b2-a689-11e6-943f-6bcc6183f3da.png\" alt=\"img\" title=\"컨트롤 바\"></p>\n<p>레코딩할 이벤트 종류로 자바스크립트 스택트레이스를 포함하려면 JS Profile 체크 박스를 활성화 해야 한다. 이외 각 체크 박스로 추가되는 정보의 내용은 체크박스 레이블로 바로 알 수 있는데 이중 Screenshots를 선택하면 측정 시간대별 웹페이지의 스크린샷을 기록한다. 화면에서 그려지는 내용의 변화를 확인할 때 매우 유용하게 사용된다. 이제 레코딩을 해보자. 컨트롤 바의 맨 왼편의 동그란 버튼이 레코딩 버튼이고 그 바로 옆의 버튼은 레코딩된 내용을 지워 버리는 버튼이다. 레코딩을 버튼을 누르자.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20128280/6337dca6-a68a-11e6-82a1-e71edaa49438.png\" alt=\"img\" title=\"레코딩 상태창\"></p>\n<p>레코딩을 누르면 레코딩 상태창이 나온다 측정할 동작이 끝나면 <strong>Stop</strong> 버튼을 눌러 측정된 결과를 확인할 수 있다.</p>\n<h3>오버뷰와 플레임차트</h3>\n<p>아래의 이미지는 성능에 문제가 있었던 innerHTML의 첫번째 구현 코드를 측정한 것이다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20129718/2b4b88f0-a695-11e6-9580-a127d9a3385f.png\" alt=\"img\" title=\"성능에 문제가 있는 구현의 레코딩 데이터\"></p>\n<p>컨트롤 바 밑으로는 측정된 결과를 조망해볼 수 있는 오버뷰가 있다. 시간의 변화에 따른 CPU의 사용량과 FPS, 네트워크의 사용 내용의 변동 추이를 확인할 수 있다. 오버뷰에서는 측정 시간 동안의 전반적인 상황을 살펴볼 수 있고 오버뷰 밑으로는 바 형태로 세부 이벤트들이 표현되는 플레임차트(Flame Chart)와 디테일뷰를 통해 각 이벤트에 대한 자세한 정보를 확인할 수 있다. 오버뷰에서 플레임 차트로 이어지는 중간에 약간 붉은바가 보이고 그 안에 1171.3ms라고 적혀있는데 이 바는 한 프레임(frame)을 뜻하고 붉은색을 띄는건 한 프레임이 너무 길다는 뜻이다. 여기서의 프레임은 한 화면을 갱신하는데 걸린 시간이라고 생각하면 된다. 프레임에 소요된 시간이 길었기 때문에 오버뷰의 녹색 FPS(Frame per second) 그래프가 거의 바닥을 찍고 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20130657/b2087dca-a69b-11e6-8361-03b400d82c5c.png\" alt=\"img\" title=\"확대된 플레임 차트\"></p>\n<p>플레임 차트를 확대해서 세부 내용을 살펴보거나 위치를 이동하려면 오버뷰의 레인지를 컨트롤 하는 두개의 바를 조절하거나 플레임 차트에 마우스 휠과 드래그를 이용한다. 플레임 차트를 확대 해서 살펴보니 구현 코드가 들어있는 hitListener함수가 실행되는 동안 Parse HTML이라는 파란색 이벤트가 여러번 발생하고 있다. Parse HTML 이벤트는 루프안에서 매번 innerHTML을 변경 적용할때 마다 브라우저가 innerHTML의 HTML텍스트를 다시 파싱해 적용하기 때문에 발생했다. 브라우저의 필요 동작에 따라 더 발생하기도 하는데 루프가 천 번을 돌았으니 적어도 천 번이상의 Parse HTML이벤트가 발생한것이다. 그리고 이미지에는 나타나지 않았지만 심지어 중간에 몇번이나 가비지 컬렉터가 돌아갔다.</p>\n<p>그리고 첫 Parse HTML 이벤트와 마지막 이벤트의 지속 시간을 비교해보면</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20131054/45a061cc-a69e-11e6-9a91-1a63627a37a9.png\" alt=\"img\" title=\"첫 Parse HTML 이벤트\"></p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20130896/464446f8-a69d-11e6-8ed4-fb41f06107bb.png\" alt=\"img\" title=\"마지막 Parse HTML 이벤트\"></p>\n<p>첫번째 이벤트는 0.04ms 마지막 이벤트는 1.24ms로 큰 차이가 난다. 루프가 돌면 돌수록 기존에 적용된 이미 만들어진 엘리먼트들도 모두 지우고 다시 파싱해 생성하기 때문에 시간이 늘어난 것이다. Parse HTML 이벤트의 발생 횟수와 시간의 증가 이렇게 두가지 문제점이 측정결과로 나타났다.</p>\n<p>성능이 개선된 두번째 구현의 측정 결과를 확인해보자.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20132198/22c625ea-a6a5-11e6-8fb6-8cd1c4549c5f.png\" alt=\"img\" title=\"성능이 개선된 구현의 레코딩 데이터\"></p>\n<p>전체적으로 성능이 개선되어 브라우저의 내부동작이 줄었기 때문에 오버뷰에서 측정된 데이터의 범위도 좁다. 프레임의 시간이 줄었기 때문에 FPS도 많이 올라갔다. 아무래도 1000개의 엘리먼트를 한번에 그리는 작업이다 보니 FPS가 약간 떨어지는 것은 어쩔수 없다. 프레임바를 보면 총 소요시간도 21.9ms으로 이전의 1171.3ms에 비하면 어마어마하게 빨라졌다. innerHTML에 1000개의 태그를 담은 HTML텍스트를 단 한 번만 적용 했기 때문에 플레임차트에서 보여주듯 함수가 실행되는 동안 발생한 Parse HTML 이벤트는 단 한번이고 소요된 시간도 0.98ms밖에 안된다. 이렇게 타임라인은 자바스크립트의 구현에 따라 어떻게 성능이 떨어졌고 혹은 개선되었는지에 대한 판단 근거들을 제공한다.</p>\n<h3>레이아웃 이벤트</h3>\n<p>레이아웃 이벤트는 리플로우라고도 한다. 주로 엘리먼트의 사이즈나 위치등 말 그대로 엘리먼트의 레이아웃이 변경될때 발생하는 작업이다. 엘리먼트들은 서로 위치나 사이즈에 영향을 주거나 받는다.(블럭요소나 인라인요소등) 특정 엘리먼트의 레이아웃이 변경되면 렌더트리가 다시 배치되면서 레이아웃에 관련된 속성들을 재계산 하는 작업이 필요하게 되는데 이때 발생하는게 레이아웃 이벤트다. 이런 레이아웃 이벤트는 수행시간이나 수행횟수에 의해 성능에 영향을 주게 된다. 원인과 해결방법은 여러가지가 있는데 간단한 예를 통해 레이아웃 이벤트와 문제있는 코드를 추적하고 해결해 보자.</p>\n<h3>디테일뷰와 레이아웃 이벤트 추적</h3>\n<p>사실 UI를 다루는 이상 시각적인 효과를 위해 발생하는 꼭 필요한 레이아웃은 이벤트는 사실 피할 수가 없다. 다만 불필요하게 발생하는 케이스를 줄이는 작업은 필요하다. 아래와 같은 플레임 차트는 가장 이상적인 모습이라고 볼 수 있다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20168081/21a61846-a763-11e6-9000-44bdae2d9c54.png\" alt=\"img\" title=\"이상적인 레이아웃 이벤트\"></p>\n<p>버튼이 클릭되면 특정 엘리먼트의 height를 변경하는 단순한 구현의 플레임 차트이다. 자바스크립트 함수(hitListener)의 실행이 종료되고 뒤이어 레이아웃 이벤트가 한번 발생했다. 리스너 함수에서 DOM 엘리먼트의 height를 변경하는 속성을 조작했기 때문에 레이아웃이 발생한 것이다. 여기서 디테일 뷰를 이용해 레이아웃 이벤트에 관한 자세한 정보를 얻을 수 있다. 플레임 차트에서 레이아웃 이벤트를 클릭하면 디테일뷰에서 해당 이벤트에 관한 정보가 나온다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20168215/0b96a3da-a764-11e6-8eb2-8b7058215ce5.png\" alt=\"img\" title=\"디테일 뷰\"></p>\n<p>디테일뷰의 Summary탭에는 선택된 이벤트의 수행 시간 및 이벤트에 특정된 정보들이 노출되게 된다. 그뒤로 이어지는 Bottom-up, Call Tree, Event Log들은 선택된 이벤트의 하위 이벤트들을 여러가지 형태로 정리해서 보여준다. 하나씩 선택해서 보면 각 탭의 특징을 파악할 수 있다. 우린 디테일뷰에서 레이아웃 이벤트를 발생하게 만든 코드를 찾아 보려고 한다. Summary탭 하단의 First Layout invalidation 정보에서 레이아웃의 발생원인을 찾을 수 있다. First가 붙어 첫번째 원인만 알려주는 이유는 레이아웃 이벤트는 실행되는 자바스크립트 코드중 원인이 되는 코드 라인이 1개가 아니라 1000개라도 첫번째 코드에 의해 한번만 발생 하기때문에 처음 코드라인에 대한 정보만을 표기한다. script2.js라는 파일에 6번째 라인이라고 표시 되어있다. 클릭하면 해당 코드로 이동된다.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20168453/b277a838-a765-11e6-99a5-bf7b7708837f.png\" alt=\"img\" title=\"코드 보기\"></p>\n<p>엘리먼트의 기존의 height값을 읽어와 10증가시키고 다시 적용하는 코드이다. 정확하게 커서가 height를 엘리먼트에 적용하는 부분에 멈춰있다. 여기서 발생한 레이아웃 이벤트는 height를 변경한다는 시각적인 UI스펙을 구현하기 위해서는 어쩔 수 없는 부분이기 때문에 이 코드는 개선할 여지가 없다. 그러면 문제가 되는 구현의 플레임 차트를 살펴보자.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20168602/703cd942-a766-11e6-9354-3ae38e4e9aa9.png\" alt=\"img\" title=\"불필요한 레이아웃 이벤트 발생\"></p>\n<p>이번 구현은 아까 height를 바꾼 코드에 이어서 비슷한 내용으로 width도 변경하는 내용이 추가된 구현이다. 자바스크립트 실행이 끝나고 레이아웃이 발생하는 것은 그대로 인데 hitListener함수가 실행되는 중간에 추가로 레이아웃 이벤트가 발생했다. 심지어 이 레이아웃 이벤트의 마우스 툴팁에는 리플로는 성능에 병목을 가져온다고 빨갛게 경고하고 있다. 해당 레이아웃 이벤트를 클릭해서 디테일뷰를 살펴보자.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20168748/1bac63a6-a767-11e6-94cb-7b6d26a61e25.png\" alt=\"img\" title=\"문제가 있는 디테일 뷰\"></p>\n<p>디테일 뷰에서도 상단에 크게 경고문구가 떠있다. 그리고 First Layout invalidation항목 위에 한가지 항목이 더 추가되었다. Layout Forced라는 항목인데 레이아웃이 스크립트 실행이 완료된 후 발생하지 않고 스크립트 실행중에 <strong>당겨져서</strong> 발생했을 때 표시된다. 해당 코드때문에 중간에 레이아웃이 발생했다는 것이다. 해당 코드를 따라가 보자.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/389021/20168870/abd2567a-a767-11e6-95d6-bea749e2dde2.png\" alt=\"img\" title=\"문제가 발생한 코드\"></p>\n<p>Layout Forced에서 지목한 라인은 18번째 라인이다. 엘리먼트의 width값을 읽어오는 부분인데 이 부분이 왜 문제가 될까? 아래 코드에 주석으로 브라우저가 해당 코드를 실행하면서 판단하는 내용들을 임의로 적어봤다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> newHeight <span class=\"token operator\">=</span> el<span class=\"token punctuation\">.</span>offsetHeight <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 특별한 작업 없음</span>\nel<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> newHeight <span class=\"token operator\">+</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 레이아웃 속성이 변경되었으니 코드 실행이 끝나면 레이아웃 작업을 해야겠다.</span>\n\n<span class=\"token keyword\">var</span> newWidth <span class=\"token operator\">=</span> el<span class=\"token punctuation\">.</span>offsetWidth <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 앗? 여기서 레이아웃 속성을 읽어오니까 바로 레이아웃 작업을 수행하고 값을 전달해야겠다. - 레이아웃 발생(1)</span>\nel<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> newWidth <span class=\"token operator\">+</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 레이아웃 속성이 변경되었으니 코드 실행이 끝나면 레이아웃 작업을 해야겠다.</span>\n\n<span class=\"token comment\">//코드 수행이 끝나고 레이아웃 작업 - 레아아웃 발생(2)</span></code></pre></div>\n<p>레이아웃 작업이 수행되기 전에 레이아웃 관련 속성을 읽는 자바스크립트 코드가 실행이 되어 해당 속성의 값을 넘겨주기 전에 미리 레이아웃을 당겨서 수행하는 것이다. 관련있는 엘리먼트들의 속성값들을 재계산해서 정확한 값으로 갱신해야 하기 때문이다. 이 문제를 해결하는 방법은 매우 간단한 편인데 레이아웃 관련 속성을 변경하는 코드가 1번이 되었던 1000번이 되었던 레이아웃 이벤트는 한 번만 발생한다는 사실이 단서가 된다. 간단하게 코드의 위치를 변경하는 것으로 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> newHeight <span class=\"token operator\">=</span> el<span class=\"token punctuation\">.</span>offsetHeight <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 특별한 작업 없음</span>\n<span class=\"token keyword\">var</span> newWidth <span class=\"token operator\">=</span> el<span class=\"token punctuation\">.</span>offsetWidth <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 특별한 작업 없음</span>\n\nel<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> newHeight <span class=\"token operator\">+</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 레이아웃 속성이 변경되었으니 코드 실행이 끝나면 레이아웃 작업을 해야겠다.</span>\nel<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> newWidth <span class=\"token operator\">+</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 특별한 작업 없음</span>\n\n<span class=\"token comment\">//코드 수행이 끝나고 레이아웃 작업 - 레이아웃 발생(1)</span></code></pre></div>\n<p>엘리먼트의 레이아웃 속성을 변경하기 전에 미리 필요한 속성의 값을 읽어온 이후에 레이아웃 관련 속성을 수정 적용했다. 이후 플레임 차트의 모습은 다시 레이아웃이 한번만 발생하는 이상적인 모습이 된다. 사실 이 예는 문제가 전혀 되지 않을 정도의 작은 부분이지만 큰 UI의 성능을 개선 할때도 비슷한 방식으로 레이아웃 이벤트가 자주 발생하거나 수행 시간이 긴 부분의 구현을 구간 구간 추적해서 구현을 달리해 해결하는 방법으로 성능을 향상할 수 있다. 레이아웃 이벤트의 수행시간 역시 성능에 큰 영향을 주고 또 다루지 않았지만 리페인트(repaint)로 알려져있는 Recalculate Style 이벤트도 성능을 개선할 포인트가 될 수 있다.</p>\n<h3>정리</h3>\n<p>당연한 말이겠지만 프론트 엔드의 성능이 저하되는 원인은 일일이 다 열거 할 수 없을 정도로 많이 있다. 타임라인은 브라우저 내부의 동작들을 살펴보며 성능에 영향을 주는 문제를 발견하는 데에는 현재로서는 유일무이한 도구라고 생각한다. 플레임 차트에서 발생하는 이벤트의 종류는 <a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference\">구글 개발자 사이트</a>에서 잘 정리되어 있다. 직접 구현한 코드에서 시간을 많이 잡아 먹는 이벤트가 발생한다면 해당 이벤트에 대한 정보를 수집해 개선할 방법을 찾아 보는 것으로 성능 향상을 꾀할 수 있다.</p>","fields":{"slug":"/2016-11-15-크롬개발자도구를 이용한 프론트엔드 성능측정/"},"excerpt":"크롬 개발자 도구를 이용한 프론트엔드 성능 측정 타임라인 타임라인은 웹페이지를 로드할때나 혹은 유저 인터렉션 등으로 인해 브라우저에서 발생하는 동작들을 레코딩하고 타임라인 형태로 시각화해주는 도구다. 시간의 흐름에 따라 브라우저의 이벤트(여기서의 이벤트는 DOM상의 이벤트가 아닌 브라우저 내부의 동작, 물론 DOM이벤트를 발생시키는 이벤트도 있다)뿐 아니라 CPU, 메모리, 네트워크 사용량과 FPS까지 확인 가능하다. 이벤트에 스택 트레이스 형태로 자바스크립트의 함수 콜 스택도 확인이 가능해 어떤 자바스크립트 코드가 성능에 영향을…","frontmatter":{"title":"크롬 개발자 도구를 이용한 프론트엔드 성능 측정","date":"15 November, 2016","categories":"frontend, tool","image":null,"imageAuthor":null,"imageAuthorLink":null,"imageFromLink":null,"imageFrom":null}},"recomendPost":{"nodes":[{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-07-27-1/"},"frontmatter":{"title":"이벤트 핸들러를 대하는 개발자의 자세","categories":"frontend, refactoring","date":"27 July, 2020"},"excerpt":"이벤트 핸들러는 UI를 개발할 때면 항상 사용된다. 웹뿐만 아니라 네이티브 어플리케이션에서도 약간의 차이가 있을뿐 거의 동일한 추상이 사용된다. 자주 사용되는 만큼 중요하지만 사실 너무 자주 사용되다 보니 가볍게 생각하며 습관적으로 고민 없이 좋지 않은 코드를 만들곤 한다. 자주 사용된다는 건 코드의 양적인 비중도 크다는 것이고 그만큼 조금만 더 신경 쓴다면 큰 효과를 볼 수도 있다. 이런 이벤트 핸들러를 어떻게 다루면 좋은지에 대해 간략하게 정리해봤다. 이벤트 핸들러라고 해서 꼭 DOM 이벤트에만 해당하는 것은 아니며 모듈 간의…"},{"fields":{"slug":"/2019-05-22-크롬 네이티브 레이지 로딩/"},"frontmatter":{"title":"크롬 네이티브 레이지 로딩","categories":"frontend, tool","date":"22 May, 2019"},"excerpt":"레이지 로딩이란? 좋은 기회로 2019년 구글I/O에 참석했다. 웹 기술 세션 중에는 크게 눈에 띄는 세션은 없었지만, 일부 세션에서 소개된 웹과 관련 기술 몇 가지는 흥미로웠다. Native Lazy Loading, Portals, Duplex, Rich Results 정도가 나의 관심을 끌었다. 그중 키노트에서 시작해 몇 개의 세션에서 두루두루 언급한 네이티브 레이지 로딩이 제일 기대됐다. 관련 세션 레이지 로딩, 특히 이미지 레이지 로딩은 새로운 기술은 아니다. 기존 브라우저는 웹페이지를 불러올 때 초기부터 전체 영역에 해당…"},{"fields":{"slug":"/2017-11-13-이맥스와 함께하는 개발환경/"},"frontmatter":{"title":"이맥스와 함께하는 개발환경","categories":"tool","date":"13 November, 2017"},"excerpt":"금단의 영역에 손을 대다 에디터, IDE뿐 아니라 업무에 관련된 새로운 도구가 나오면 꼭 써봐야 직성이 풀리는 성격이었지만 언젠가부터 그놈이 그놈이고 저놈이 그놈이고 새로운 기능이 있어도 개발을 할 때 사용하는 기능들은 매우 한정적이라는 사실을 깨닫게 되었다. 인텔리제이도 일년 이상은 사용해봤지만 프론트 엔드를 주로 개발하기에 딱히 IDE가 필요하지 않았고 수많은 기능들을 거의 사용하지 않다 보니 필요 이상의 도구를 사용하는 느낌이었다. 그런 느낌이 조금씩 자라나던 중 생뚱맞게도 박웅현 작가의 **여덟 단어** 라는 책을 읽다가 …"}]},"recentPost":{"nodes":[{"fields":{"slug":"/2021-04-20/"},"frontmatter":{"title":"욕 안 먹는 개발자되기","categories":"developer","date":"20 April, 2021"},"excerpt":"직장인이라면 자연스럽게 업무를 대하는 태도가 캐릭터 처럼 만들어져요. 개발자도 마찬가지고요. 신입이라고 태도가 항상 나쁜 것도 아니고 경력이라고 항상 태도가 좋은 것도 아니에요. 코딩 스킬처럼 개선될 수도 있고요. 연차가 적을수록 몰라서 잘못된 태도를 갖는 경우가 많습니다. 이렇게 만들어진 태도는 보통 연차가 높을수록 개선되기 힘들다고들 하죠. 태도라는 큰 추상적인 덩어리는 억울하게도 한 부분, 한 사건에 의해 모든 것을 퉁쳐서 판단되기도 하죠. 이런 태도의 중요한 한 부분은 업무 중 문제가 발생했을 때에 뚜렷하게 나타난다고 생각…"},{"fields":{"slug":"/2021-02-22/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 2","categories":"frontend, nodejs, tdd","date":"22 February, 2021"},"excerpt":"파트 1에서는 기본 자바스크립트 개발 환경을 러나와 함께 구축해봤어요. 기본 환경만으로 충분하신 분들도 계시겠지만 보통은 그렇지 않을 겁니다.\n이제 두 가지 개발 환경을 추가할 건데요. 타입 스크립트와 리액트 개발 환경이에요. 우선 타입스크립트 환경을부터 추가할 거예요. 그전에 러나로 해줘야 할 작업이 있습니다. 타입스크립트 환경도 결국 지금까지 저희가 구축한 자바스크립트 환경 위에 만들어질 것이기 때문에 디펜던시 모듈을 공유할 수 있도록 만들고 환경 설정 파일들도 기본 자바스크립트의 환경설정 파일들을 확장해서 사용할 거예요. 그…"},{"fields":{"slug":"/2021-02-15/"},"frontmatter":{"title":"코딩 플레이그라운드 만들며 맛보는 요즘 FE 개발 환경 Part 1","categories":"frontend, nodejs, tdd","date":"15 February, 2021"},"excerpt":"개발을 하다 보면 특정 환경에서 빠르게 코드를 작성하고 그 결과를 확인해보고 싶을 때가 있어요. 라이브러리나 프레임웍 혹은 언어를 공부할 때나 아이디어를 빠르게 실험하거나 프로토타입 해보고 싶을 때 그렇지요. 바닐라 자바스크립트로 충분한 환경이라면 디렉터리 하나 만들고 js 파일 하나 html 파일 하나 만들어서 에디터를 열고 브라우저를 열어서 html 파일을 불러오는 것까지 하면 기본적인 준비가 끝나요. 근데요. 이런 바닐라 자바스크립트 환경을 만드는 것조차도 사실 귀찮을 때가 있어요. 이런 기본 환경도 귀찮은데 실무의 복잡한 …"},{"fields":{"slug":"/2020-12-01/"},"frontmatter":{"title":"browserslist 쾌속 가이드","categories":"frontend, nodejs","date":"01 December, 2020"},"excerpt":"언젠가부터 브라우저스리스트(browserslist)라는 것이 자주 눈에 띄더니 지금은 FE 개발 환경에서 뺄 수 없는 도구가 되었어요. 아마도 바벨(Babel)이라는 FE 계의 걸출한 스타 프로젝트에서 도입했기 때문일 거라고 생각합니다. 바벨을 사용하는 프로젝트들이 많다 보니 간접적으로 혹은 직접적으로 브라우저스리스트까지 사용하게 되는 것이죠. 사실 좋아요 좋은 도구라고 생각합니다. 아마 브라우저 환경을 정의하는 표준처럼 당분간 사용될 것 같아요. 보통 공식 사이트에서 자세히 알 수 있는 내용들은 글을 따로 안 쓰려고 하는 편인데…"},{"fields":{"slug":"/2020-11-23/"},"frontmatter":{"title":"누구나 원하는 개발자되기","categories":"developer, recruit","date":"23 November, 2020"},"excerpt":"5~6년 차 즈음부터 개발자 채용에 조금씩 관여하기 시작했고 현 회사에서는 면접관으로 활동한지 5년이 넘은 것 같다. 면접은 1차 면접에 해당하는 기술 면접이었고 팀의 채용 프로세스를 개선하거나 사전과제, 라이브 코딩 문제 출제에 주도적으로 참여했다. 그간 다양한 개발자들을 만났고 운 좋게도 좋은 개발자들을 많이 채용할 수 있었다. 채용 과정에서 좋은 개발자도 만났지만 그렇지 못했던 개발자도 많았고, 아쉬웠던 개발자도 있었다. 아쉬웠던 개발자들은 노력을 하고 있지만 “어느 정도”로 “어떤 방향”으로 해야 하는지 모르는 경우였고 채…"},{"fields":{"slug":"/2020-10-05/"},"frontmatter":{"title":"독서 습관을 만드는 구체적인 방법","categories":"motivation, life","date":"05 October, 2020"},"excerpt":"독서를 습관으로 만들기 위해 그간 많은 노력을 했었다. 습관적으로 SNS를 열면서 “이럴 시간에 책을 읽었으면…” 하고 자주 생각했지만 SNS 아이콘을 터치하는 유혹을 뿌리치기 힘들었다. 여러 가지 시도를 했고  “하루 25분 실행하기: 하루를 대하는 14년차 개발자의 자세” 에서 밝혔다시피 아직 다독가에 비하면 보잘것없지만 그래도 나름 습관 만들기에는 성공한 것 같다. 독서 습관을 만들면서 알게 된 몇가지 좋은 팁을 공유한다. 읽기 속도 측정하기 독서 습관을 만들 때 제일 중요한 것은 책 읽는 속도를 파악하는 것이라고 생각한다.…"}]}},"pageContext":{"slug":"/2016-11-15-크롬개발자도구를 이용한 프론트엔드 성능측정/","categoriesRegex":"/frontend|tool/g"}},"staticQueryHashes":["1529427419","1755485493","2738229898","993531770"]}